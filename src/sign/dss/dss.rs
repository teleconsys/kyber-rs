// Package dss implements the Distributed Schnorr Signature protocol from the
// paper "Provably Secure Distributed Schnorr Signatures and a (t, n)
// Threshold Scheme for Implicit Certificates".
// https://dl.acm.org/citation.cfm?id=678297
// To generate a distributed signature from a group of participants, the group
// must first generate one longterm distributed secret with the share/dkg
// package, and then one random secret to be used only once.
// Each participant then creates a DSS struct, that can issue partial signatures
// with `dss.PartialSignature()`. These partial signatures can be broadcasted to
// the whole group or to a trusted combiner. Once one has collected enough
// partial signatures, it is possible to compute the distributed signature with
// the `Signature` method.
// The resulting signature is compatible with the EdDSA verification function.
// against the longterm distributed key.

use anyhow::{bail, Ok, Result};
use blake2::Digest;
use sha2::Sha512;
use std::collections::HashMap;

use crate::{
    encoding::Marshaling,
    group::{HashFactory, PointCanCheckCanonicalAndSmallOrder, ScalarCanCheckCanonical},
    share::poly::{self, PriShare, PubPoly},
    sign::{eddsa, schnorr},
    Group, Point, Random, Scalar,
};

/// Suite represents the functionalities needed by the dss package
pub trait Suite: Group + HashFactory + Random + Clone {}

/// DistKeyShare is an abstraction to allow one to use distributed key share
/// from different schemes easily into this distributed threshold Schnorr
/// signature framework.
pub trait DistKeyShare<POINT: Point>: Clone {
    fn pri_share(&self) -> PriShare<POINT::SCALAR>;
    fn commitments(&self) -> Vec<POINT>;
}

/// DSS holds the information used to issue partial signatures as well as to
/// compute the distributed schnorr signature.
pub struct DSS<SUITE: Suite, DKS: DistKeyShare<SUITE::POINT>> {
    suite: SUITE,
    pub(crate) secret: <SUITE::POINT as Point>::SCALAR,
    pub public: SUITE::POINT,
    index: usize,
    participants: Vec<SUITE::POINT>,
    t: usize,
    long: DKS,
    random: DKS,
    long_poly: PubPoly<SUITE>,
    random_poly: PubPoly<SUITE>,
    pub msg: Vec<u8>,
    pub partials: Vec<Option<PriShare<<SUITE::POINT as Point>::SCALAR>>>,
    partials_idx: HashMap<usize, bool>,
    signed: bool,
    session_id: Vec<u8>,
}

/// PartialSig is partial representation of the final distributed signature. It
/// must be sent to each of the other participants.
#[derive(Clone)]
pub struct PartialSig<SUITE: Suite> {
    pub partial: PriShare<<SUITE::POINT as Point>::SCALAR>,
    pub session_id: Vec<u8>,
    pub signature: Vec<u8>,
}

impl<SUITE: Suite> PartialSig<SUITE> {
    /// Hash returns the hash representation of this PartialSig to be used in a
    /// signature.
    pub fn hash(&self, s: SUITE) -> Result<Vec<u8>> {
        let mut h = s.hash();
        h.update(&self.partial.hash(s)?);
        h.update(&self.session_id);
        Ok(h.finalize().to_vec())
    }
}

/// NewDSS returns a DSS struct out of the suite, the longterm secret of this
/// node, the list of participants, the longterm and random distributed key
/// (generated by the dkg package), the message to sign and finally the T
/// threshold. It returns an error if the public key of the secret can't be found
/// in the list of participants.
pub fn new_dss<SUITE: Suite, DKS: DistKeyShare<SUITE::POINT>>(
    suite: SUITE,
    secret: &<SUITE::POINT as Point>::SCALAR,
    participants: &[SUITE::POINT],
    long: &DKS,
    random: &DKS,
    msg: &[u8],
    t: usize,
) -> Result<DSS<SUITE, DKS>> {
    let public = suite.point().mul(&secret, None);
    let mut i = 0;
    let mut found = false;
    for (j, p) in participants.iter().enumerate() {
        if p.equal(&public) {
            found = true;
            i = j;
            break;
        }
    }
    if !found {
        bail!("dss: public key not found in list of participants");
    }

    Ok(DSS::<SUITE, DKS> {
        suite: suite.clone(),
        secret: secret.clone(),
        public: public,
        index: i,
        participants: participants.to_vec(),
        long: long.clone(),
        long_poly: PubPoly::new(&suite, Some(suite.point().base()), long.commitments()),
        random: random.clone(),
        random_poly: PubPoly::new(&suite, Some(suite.point().base()), random.commitments()),
        msg: msg.to_vec(),
        t: t,
        partials_idx: HashMap::new(),
        session_id: session_id(suite, long, random)?,
        partials: Vec::new(),
        signed: false,
    })
}

impl<SUITE: Suite, DKS: DistKeyShare<SUITE::POINT>> DSS<SUITE, DKS> {
    /// PartialSig generates the partial signature related to this DSS. This
    /// PartialSig can be broadcasted to every other participant or only to a
    /// trusted combiner as described in the paper.
    /// The signature format is compatible with EdDSA verification implementations.
    pub fn partial_sig(&mut self) -> Result<PartialSig<SUITE>> {
        // following the notations from the paper
        let alpha = self.long.pri_share().v;
        let beta = self.random.pri_share().v;
        let hash = self.hash_sig()?;
        let right = hash * alpha;
        let mut ps = PartialSig {
            partial: PriShare {
                v: right + beta,
                i: self.index,
            },
            session_id: self.session_id.clone(),
            signature: Vec::new(),
        };
        let msg = ps.hash(self.suite.clone())?;
        ps.signature = schnorr::sign(&self.suite, &self.secret, &msg)?;
        if !self.signed {
            self.partials_idx.insert(self.index, true);
            self.partials.push(Some(ps.partial.clone()));
            self.signed = true
        }
        Ok(ps)
    }

    /// ProcessPartialSig takes a PartialSig from another participant and stores it
    /// for generating the distributed signature. It returns an error if the index is
    /// wrong, or the signature is invalid or if a partial signature has already been
    /// received by the same peer. To know whether the distributed signature can be
    /// computed after this call, one can use the `EnoughPartialSigs` method.
    pub fn process_partial_sig(&mut self, ps: PartialSig<SUITE>) -> Result<()>
    where
        <SUITE::POINT as Point>::SCALAR: Scalar + ScalarCanCheckCanonical,
        SUITE::POINT: PointCanCheckCanonicalAndSmallOrder,
    {
        let public = find_pub(&self.participants, ps.partial.i)?;

        let msg = ps.hash(self.suite.clone())?;
        schnorr::verify(self.suite.clone(), &public, &msg, &ps.signature)?;

        // nothing secret here
        if ps.session_id != self.session_id {
            bail!("dss: session id do not match")
        }

        if self.partials_idx.contains_key(&ps.partial.i) {
            bail!("dss: partial signature already received from peer")
        }

        let hash = self.hash_sig()?;
        let idx = ps.partial.i;
        let rand_share = self.random_poly.eval(idx);
        let long_share = self.long_poly.eval(idx);
        let mut right = self.suite.point().mul(&hash, Some(&long_share.v));
        let right_clone = right.clone();
        right = right.add(&rand_share.v, &right_clone);
        let left = self.suite.point().mul(&ps.partial.v, None);
        if !left.equal(&right) {
            bail!("dss: partial signature not valid")
        }
        self.partials_idx.insert(ps.partial.i, true);
        self.partials.push(Some(ps.partial));
        Ok(())
    }

    /// EnoughPartialSig returns true if there are enough partial signature to compute
    /// the distributed signature. It returns false otherwise. If there are enough
    /// partial signatures, one can issue the signature with `Signature()`.
    pub fn enough_partial_sig(&self) -> bool {
        return self.partials.len() >= self.t;
    }

    /// Signature computes the distributed signature from the list of partial
    /// signatures received. It returns an error if there are not enough partial
    /// signatures. The signature is compatible with the EdDSA verification
    /// alrogithm.
    pub fn signature(&self) -> Result<Vec<u8>> {
        if !self.enough_partial_sig() {
            bail!("dss: not enough partial signatures to sign")
        }
        let gamma = poly::recover_secret(
            self.suite.clone(),
            &self.partials,
            self.t,
            self.participants.len(),
        )?;
        // RandomPublic || gamma
        let mut buff = Vec::new();
        self.random.commitments()[0].marshal_to(&mut buff)?;
        gamma.marshal_to(&mut buff)?;
        Ok(buff)
    }

    fn hash_sig(&self) -> Result<<SUITE::POINT as Point>::SCALAR> {
        // H(R || A || msg) with
        //  * R = distributed random "key"
        //  * A = distributed public key
        //  * msg = msg to sign
        let mut h = Sha512::new();
        self.random.commitments()[0].marshal_to(&mut h)?;
        self.long.commitments()[0].marshal_to(&mut h)?;
        h.update(self.msg.clone());
        Ok(self.suite.scalar().set_bytes(&h.finalize()))
    }
}

/// Verify takes a public key, a message and a signature and returns an error if
/// the signature is invalid.
pub fn verify<POINT: Point>(public: &POINT, msg: &[u8], sig: &[u8]) -> Result<()> {
    eddsa::verify(public, msg, sig)
}

fn find_pub<POINT: Point>(list: &[POINT], i: usize) -> Result<POINT> {
    if i >= list.len() {
        bail!("dss: invalid index")
    }
    Ok(list[i].clone())
}

fn session_id<SUITE: Suite, DKS: DistKeyShare<SUITE::POINT>>(
    s: SUITE,
    a: &DKS,
    b: &DKS,
) -> Result<Vec<u8>> {
    let mut h = s.hash();
    for p in a.commitments() {
        p.marshal_to(&mut h)?;
    }

    for p in b.commitments() {
        p.marshal_to(&mut h)?;
    }

    Ok(h.finalize().to_vec())
}
