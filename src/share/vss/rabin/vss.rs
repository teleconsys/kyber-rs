// Package vss implements the verifiable secret sharing scheme from the
// paper "Provably Secure Distributed Schnorr Signatures and a (t, n) Threshold
// Scheme for Implicit Certificates".
// VSS enables a dealer to share a secret securely and verifiably among n
// participants out of which at least t are required for its reconstruction.
// The verifiability of the process prevents a
// malicious dealer from influencing the outcome to his advantage as each
// verifier can check the validity of the received share. The protocol has the
// following steps:
//
//   1) The dealer send a Deal to every verifiers using `Deals()`. Each deal must
//   be sent securely to one verifier whose public key is at the same index than
//   the index of the Deal.
//
//   2) Each verifier processes the Deal with `ProcessDeal`.
//   This function returns a Response which can be twofold:
//   - an approval, to confirm a correct deal
//   - a complaint to announce an incorrect deal notifying others that the
//     dealer might be malicious.
//	 All Responses must be broadcasted to every verifiers and the dealer.
//   3) The dealer can respond to each complaint by a justification revealing the
//   share he originally sent out to the accusing verifier. This is done by
//   calling `ProcessResponse` on the `Dealer`.
//   4) The verifiers refuse the shared secret and abort the protocol if there
//   are at least t complaints OR if a Justification is wrong. The verifiers
//   accept the shared secret if there are at least t approvals at which point
//   any t out of n verifiers can reveal their shares to reconstruct the shared
//   secret.

use std::collections::HashMap;
use std::marker::PhantomData;

use crate::group::HashFactory;
use crate::share::poly::{NewPriPoly, PriShare};
use crate::sign::schnorr;
use crate::Scalar;
use crate::{cipher::Stream, Group, Point, Random, XOFFactory};

use crate::group::edwards25519::{scalar::Scalar as EdScalar, Point as EdPoint, SuiteEd25519};

use anyhow::{bail, Error, Ok, Result};
use byteorder::{LittleEndian, WriteBytesExt};
use digest::DynDigest;
use std::ops::{Deref, DerefMut};

use super::dh::{context, dhExchange};

/// Suite defines the capabilities required by the vss package.
pub trait Suite<SCALAR, POINT>:
    Group<SCALAR, POINT> + HashFactory + XOFFactory + Random + Clone + Copy
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
}

/// Dealer encapsulates for creating and distributing the shares and for
/// replying to any Responses.
pub struct Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    suite: SUITE,
    // reader: STREAM,
    // long is the longterm key of the Dealer
    long: SCALAR,
    pubb: POINT,
    pub secret: SCALAR,
    secret_commits: Vec<POINT>,
    verifiers: Vec<POINT>,
    hkdf_context: Vec<u8>,
    // threshold of shares that is needed to reconstruct the secret
    t: usize,
    // sessionID is a unique identifier for the whole session of the scheme
    session_id: Vec<u8>,
    // list of deals this Dealer has generated
    // deals: []*Deal,
    aggregator: Aggregator<SUITE, POINT, SCALAR>,
}

impl<SCALAR, SUITE, POINT> Deref for Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    type Target = Aggregator<SUITE, POINT, SCALAR>;

    fn deref(&self) -> &Self::Target {
        &self.aggregator
    }
}

impl<SCALAR, SUITE, POINT> DerefMut for Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.aggregator
    }
}

/// Deal encapsulates the verifiable secret share and is sent by the dealer to a verifier.
pub struct Deal<SCALAR, POINT>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
    _phantom: PhantomData<SCALAR>,

    /// Unique session identifier for this protocol run
    session_id: Vec<u8>,
    /// Private share generated by the dealer
    sec_share: PriShare<SCALAR>,
    /// Random share generated by the dealer
    rnd_share: PriShare<SCALAR>,
    /// Threshold used for this secret sharing run
    t: usize,
    // Commitments are the coefficients used to verify the shares against
    commitments: Vec<POINT>,
}

/// EncryptedDeal contains the deal in a encrypted form only decipherable by the
/// correct recipient. The encryption is performed in a similar manner as what is
/// done in TLS. The dealer generates a temporary key pair, signs it with its
/// longterm secret key.
pub struct EncryptedDeal<POINT, SCALAR>
where
    POINT: Point<SCALAR>,
    SCALAR: Scalar,
{
    _phantom: PhantomData<SCALAR>,
    /// Ephemeral Diffie Hellman key
    dhkey: POINT,
    /// Signature of the DH key by the longterm key of the dealer
    signature: Vec<u8>,
    /// Nonce used for the encryption
    nonce: Vec<u8>,
    /// AEAD encryption of the deal marshalled by protobuf
    cipher: Vec<u8>,
}

/// Response is sent by the verifiers to all participants and holds each
/// individual validation or refusal of a Deal.
pub struct Response {
    /// SessionID related to this run of the protocol
    pub session_id: Vec<u8>,
    /// Index of the verifier issuing this Response
    pub index: u32,
    /// Approved is true if the Response is valid
    pub approved: bool,
    /// Signature over the whole packet
    pub signature: Vec<u8>,
}

/// Justification is a message that is broadcasted by the Dealer in response to
/// a Complaint. It contains the original Complaint as well as the shares
/// distributed to the complainer.
pub struct Justification<SCALAR, POINT>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
    /// SessionID related to the current run of the protocol
    session_id: Vec<u8>,
    /// Index of the verifier who issued the Complaint,i.e. index of this Deal
    index: u32,
    /// Deal in cleartext
    deal: Deal<SCALAR, POINT>,
    /// Signature over the whole packet
    signature: Vec<u8>,
}

/// NewDealer returns a Dealer capable of leading the secret sharing scheme. It
/// does not have to be trusted by other Verifiers. The security parameter t is
/// the number of shares required to reconstruct the secret. It is HIGHLY
/// RECOMMENDED to use a threshold higher or equal than what the method
/// MinimumT() returns, otherwise it breaks the security assumptions of the whole
/// scheme. It returns an error if the t is inferior or equal to 2.
pub fn NewDealer<SCALAR, POINT, SUITE>(
    suite: SUITE,
    longterm: SCALAR,
    secret: SCALAR,
    verifiers: Vec<POINT>,
    t: usize,
) -> Result<Dealer<SCALAR, SUITE, POINT>>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
    // STREAM: Stream,
{
    if !validT(t, &verifiers) {
        bail!("dealer: t {} invalid", t);
    }

    let H = deriveH(suite, &verifiers);
    let f = NewPriPoly(suite, t, Some(secret.clone()), suite.RandomStream());
    let g = NewPriPoly(suite, t, None, suite.RandomStream());
    let d_pubb = suite.point().mul(&longterm, None);

    let hkdf_context = context(&suite, &d_pubb, &verifiers).to_vec();

    // Compute public polynomial coefficients
    let F = f.Commit(suite.point().base());
    let (_, secret_commits) = F.Info();
    let G = g.Commit(H);

    let C = F.Add(&G)?;
    let (_, commitments) = C.Info();

    let session_id = sessionID(&suite, &d_pubb, &verifiers, &commitments, t)?;

    let aggregator = newAggregator(
        suite,
        d_pubb.clone(),
        verifiers.clone(),
        commitments.clone(),
        t,
        &session_id,
    );
    // C = F + G
    let mut d_deals = vec![];
    for i in 0..verifiers.len() {
        let fi = f.Eval(i);
        let gi = g.Eval(i);
        d_deals.push(Deal {
            session_id: session_id.clone(),
            sec_share: fi,
            rnd_share: gi,
            commitments: commitments.clone(),
            t: t,
            _phantom: PhantomData,
        });
    }

    Ok(Dealer {
        suite: suite,
        long: longterm,
        secret: secret,
        verifiers: verifiers,
        pubb: d_pubb,
        secret_commits,
        hkdf_context,
        t,
        session_id,
        aggregator,
    })
}

// // PlaintextDeal returns the plaintext version of the deal destined for peer i.
// // Use this only for testing.
// func (d *Dealer) PlaintextDeal(i int) (*Deal, error) {
// 	if i >= len(d.deals) {
// 		return nil, errors.New("dealer: PlaintextDeal given wrong index")
// 	}
// 	return d.deals[i], nil
// }

impl<SCALAR, SUITE, POINT> Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    /// EncryptedDeal returns the encryption of the deal that must be given to the
    /// verifier at index i.
    /// The dealer first generates a temporary Diffie Hellman key, signs it using its
    /// longterm key, and computes the shared key depending on its longterm and
    /// ephemeral key and the verifier's public key.
    /// This shared key is then fed into a HKDF whose output is the key to a AEAD
    /// (AES256-GCM) scheme to encrypt the deal.
    fn EncryptedDeal(&self, i: usize) -> Result<EncryptedDeal<POINT, SCALAR>> {
        let vPub = findPub(self.verifiers.clone(), i)
            .ok_or(Error::msg("dealer: wrong index to generate encrypted deal"))?;
        // gen ephemeral key
        let dhSecret = self.suite.scalar().pick(&mut self.suite.RandomStream());
        let dhPublic = self.suite.point().mul(&dhSecret, None);
        // signs the public key
        let dhPublicBuff = dhPublic.marshal_binary()?;
        let signature = schnorr::Sign(self.suite, self.long.clone(), &dhPublicBuff)?;

        // AES128-GCM
        let pre = dhExchange(self.suite, dhSecret, vPub);
        // gcm, err := newAEAD(self.suite.Hash, pre, self.hkdfContext)
        // if err != nil {
        // 	return nil, err
        // }

        // nonce := make([]byte, gcm.NonceSize())
        // dealBuff, err := protobuf.Encode(self.deals[i])
        // if err != nil {
        // 	return nil, err
        // }
        // encrypted := gcm.Seal(nil, nonce, dealBuff, self.hkdfContext)
        // return &EncryptedDeal{
        // 	DHKey:     dhPublic,
        // 	Signature: signature,
        // 	Nonce:     nonce,
        // 	Cipher:    encrypted,
        // }, nil
        todo!();
    }

    /// encrypted_deals calls `EncryptedDeal` for each index of the verifier and
    /// returns the list of encrypted deals. Each index in the returned slice
    /// corresponds to the index in the list of verifiers.
    pub fn encrypted_deals(&self) -> Result<Vec<EncryptedDeal<POINT, SCALAR>>> {
        // deals := make([]*EncryptedDeal, len(d.verifiers));
        let mut deals = vec![];
        // var err error
        for i in 0..self.verifiers.len() {
            let deal = self.EncryptedDeal(i)?;
            deals.push(deal);
        }
        Ok(deals)
    }

    /// process_response analyzes the given Response. If it's a valid complaint, then
    /// it returns a Justification. This Justification must be broadcasted to every
    /// participants. If it's an invalid complaint, it returns an error about the
    /// complaint. The verifiers will also ignore an invalid Complaint.
    pub fn process_response(&self, r: &Response) -> Result<Option<Justification<SCALAR, POINT>>> {
        // if err := d.verifyResponse(r); err != nil {
        // 	return nil, err
        // }
        // if r.Approved {
        // 	return nil, nil
        // }

        // j := &Justification{
        // 	SessionID: d.sessionID,
        // 	// index is guaranteed to be good because of d.verifyResponse before
        // 	Index: r.Index,
        // 	Deal:  d.deals[int(r.Index)],
        // }
        // sig, err := schnorr.Sign(d.suite, d.long, j.Hash(d.suite))
        // if err != nil {
        // 	return nil, err
        // }
        // j.Signature = sig
        // return j, nil
        todo!()
    }

    // // SecretCommit returns the commitment of the secret being shared by this
    // // dealer. This function is only to be called once the deal has enough approvals
    // // and is verified otherwise it returns nil.
    // func (d *Dealer) SecretCommit() kyber.Point {
    // 	if !d.EnoughApprovals() || !d.DealCertified() {
    // 		return nil
    // 	}
    // 	return d.suite.Point().Mul(d.secret, nil)
    // }

    // // Commits returns the commitments of the coefficient of the secret polynomial
    // // the Dealer is sharing.
    // func (d *Dealer) Commits() []kyber.Point {
    // 	if !d.EnoughApprovals() || !d.DealCertified() {
    // 		return nil
    // 	}
    // 	return d.secretCommits
    // }

    // // Key returns the longterm key pair used by this Dealer.
    // func (d *Dealer) Key() (secret kyber.Scalar, public kyber.Point) {
    // 	return d.long, d.pub
    // }

    // // SessionID returns the current sessionID generated by this dealer for this
    // // protocol run.
    // func (d *Dealer) SessionID() []byte {
    // 	return d.sessionID
    // }

    // // SetTimeout tells this dealer to consider this moment the maximum time limit.
    // // it calls cleanVerifiers which will take care of all Verifiers who have not
    // // responded until now.
    // func (d *Dealer) SetTimeout() {
    // 	d.aggregator.cleanVerifiers()
    // }

    // /// deal_certified returns true if there has been less than t complaints, all
    // /// Justifications were correct and if EnoughApprovals() returns true.
    // pub fn deal_certified(&self) -> bool {
    //     self.aggregator.deal_certified()
    // }
}

/// Verifier receives a Deal from a Dealer, can reply with a Complaint, and can
/// collaborate with other Verifiers to reconstruct a secret.
pub struct Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    suite: SUITE,
    longterm: SCALAR,
    pubb: POINT,
    dealer: POINT,
    index: usize,
    verifiers: Vec<POINT>,
    hkdfContext: Vec<u8>,
    aggregator: Option<Aggregator<SUITE, POINT, SCALAR>>,
}

/// NewVerifier returns a Verifier out of:
/// - its longterm secret key
/// - the longterm dealer public key
/// - the list of public key of verifiers. The list MUST include the public key
/// of this Verifier also.
/// The security parameter t of the secret sharing scheme is automatically set to
/// a default safe value. If a different t value is required, it is possible to set
/// it with `verifier.SetT()`.
pub fn NewVerifier<SCALAR, POINT, SUITE>(
    suite: SUITE,
    longterm: SCALAR,
    dealer_key: POINT,
    verifiers: Vec<POINT>,
) -> Result<Verifier<SCALAR, POINT, SUITE>>
where
    POINT: Point<SCALAR>,
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
{
    let p = suite.point();
    let pubb = p.mul(&longterm, None);
    let mut ok = false;
    let mut index = 0;
    for (i, v) in verifiers.iter().enumerate() {
        if v.equal(&pubb) {
            ok = true;
            index = i;
            break;
        }
    }
    if !ok {
        bail!("vss: public key not found in the list of verifiers");
    }
    let c = context(&suite, &dealer_key, &verifiers);
    Ok(Verifier {
        suite,
        longterm,
        dealer: dealer_key,
        verifiers,
        pubb,
        index,
        hkdfContext: Vec::from(c),
        aggregator: None,
    })
}

impl<SCALAR, POINT, SUITE> Deref for Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    type Target = Aggregator<SUITE, POINT, SCALAR>;

    fn deref(&self) -> &Self::Target {
        self.aggregator.as_ref().unwrap()
    }
}

impl<SCALAR, POINT, SUITE> DerefMut for Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.aggregator.as_mut().unwrap()
    }
}

impl<SCALAR, POINT, SUITE> Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    // process_encrypted_deal decrypt the deal received from the Dealer.
    // If the deal is valid, i.e. the verifier can verify its shares
    // against the public coefficients and the signature is valid, an approval
    // response is returned and must be broadcasted to every participants
    // including the dealer.
    // If the deal itself is invalid, it returns a complaint response that must be
    // broadcasted to every other participants including the dealer.
    // If the deal has already been received, or the signature generation of the
    // response failed, it returns an error without any responses.
    pub fn process_encrypted_deal(&self, e: &EncryptedDeal<POINT, SCALAR>) -> Result<Response> {
        // d, err := v.decryptDeal(e)
        // if err != nil {
        // 	return nil, err
        // }
        // if d.SecShare.I != v.index {
        // 	return nil, errors.New("vss: verifier got wrong index from deal")
        // }

        // t := int(d.T)

        // sid, err := sessionID(v.suite, v.dealer, v.verifiers, d.Commitments, t)
        // if err != nil {
        // 	return nil, err
        // }

        // if v.aggregator == nil {
        // 	v.aggregator = newAggregator(v.suite, v.dealer, v.verifiers, d.Commitments, t, d.SessionID)
        // }

        // r := &Response{
        // 	SessionID: sid,
        // 	Index:     uint32(v.index),
        // 	Approved:  true,
        // }
        // if err = v.VerifyDeal(d, true); err != nil {
        // 	r.Approved = false
        // }

        // if err == errDealAlreadyProcessed {
        // 	return nil, err
        // }

        // if r.Signature, err = schnorr.Sign(v.suite, v.longterm, r.Hash(v.suite)); err != nil {
        // 	return nil, err
        // }

        // if err = v.aggregator.addResponse(r); err != nil {
        // 	return nil, err
        // }
        // return r, nil
        todo!()
    }

    // func (v *Verifier) decryptDeal(e *EncryptedDeal) (*Deal, error) {
    // 	ephBuff, err := e.DHKey.MarshalBinary()
    // 	if err != nil {
    // 		return nil, err
    // 	}
    // 	// verify signature
    // 	if err := schnorr.Verify(v.suite, v.dealer, ephBuff, e.Signature); err != nil {
    // 		return nil, err
    // 	}

    // 	// compute shared key and AES526-GCM cipher
    // 	pre := dhExchange(v.suite, v.longterm, e.DHKey)
    // 	gcm, err := newAEAD(v.suite.Hash, pre, v.hkdfContext)
    // 	if err != nil {
    // 		return nil, err
    // 	}
    // 	decrypted, err := gcm.Open(nil, e.Nonce, e.Cipher, v.hkdfContext)
    // 	if err != nil {
    // 		return nil, err
    // 	}
    // 	deal := &Deal{}
    // 	err = deal.decode(v.suite, decrypted)
    // 	return deal, err
    // }

    /// ProcessResponse analyzes the given response. If it's a valid complaint, the
    /// verifier should expect to see a Justification from the Dealer. It returns an
    /// error if it's not a valid response.
    /// Call `v.DealCertified()` to check if the whole protocol is finished.
    pub fn process_response(&self, resp: &Response) -> Result<()> {
        // v.aggregator.verifyResponse(resp)
        todo!();
    }

    /// deal returns the Deal that this verifier has received. It returns
    /// nil if the deal is not certified or there is not enough approvals.
    pub fn deal(&self) -> Option<Deal<SCALAR, POINT>> {
        todo!()
        // if !v.EnoughApprovals() || !v.DealCertified() {
        //     return nil;
        // }
        // return v.deal;
    }

    // // ProcessJustification takes a DealerResponse and returns an error if
    // // something went wrong during the verification. If it is the case, that
    // // probably means the Dealer is acting maliciously. In order to be sure, call
    // // `v.EnoughApprovals()` and if true, `v.DealCertified()`.
    // func (v *Verifier) ProcessJustification(dr *Justification) error {
    // 	return v.aggregator.verifyJustification(dr)
    // }

    // // Key returns the longterm key pair this verifier is using during this protocol
    // // run.
    // func (v *Verifier) Key() (kyber.Scalar, kyber.Point) {
    // 	return v.longterm, v.pub
    // }

    // // Index returns the index of the verifier in the list of participants used
    // // during this run of the protocol.
    // func (v *Verifier) Index() int {
    // 	return v.index
    // }

    // // SessionID returns the session id generated by the Dealer. WARNING: it returns
    // // an nil slice if the verifier has not received the Deal yet !
    // func (v *Verifier) SessionID() []byte {
    // 	return v.sid
    // }

    // // SetTimeout tells this verifier to consider this moment the maximum time limit.
    // // it calls cleanVerifiers which will take care of all Verifiers who have not
    // // responded until now.
    // func (v *Verifier) SetTimeout() {
    // 	v.aggregator.cleanVerifiers()
    // }
}

/// Aggregator is used to collect all deals, and responses for one protocol run.
/// It brings common functionalities for both Dealer and Verifier structs.
pub struct Aggregator<SUITE, POINT, SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    _phantom: PhantomData<SCALAR>,
    suite: SUITE,
    dealer: POINT,
    verifiers: Vec<POINT>,
    commits: Vec<POINT>,

    responses: HashMap<u32, Response>,
    sid: Vec<u8>,
    deal: Option<Deal<SCALAR, POINT>>,
    t: i32,
    bad_dealer: bool,
}

fn newAggregator<SCALAR, POINT, SUITE>(
    suite: SUITE,
    dealer: POINT,
    verifiers: Vec<POINT>,
    commitments: Vec<POINT>,
    t: usize,
    sid: &[u8],
) -> Aggregator<SUITE, POINT, SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    Aggregator {
        suite: suite,
        dealer: dealer,
        verifiers: verifiers,
        commits: commitments,
        t: t as i32,
        sid: sid.clone().to_vec(),
        responses: HashMap::new(),
        deal: None,
        bad_dealer: false,
        _phantom: PhantomData,
    }
}

// var errDealAlreadyProcessed = errors.New("vss: verifier already received a deal")

impl<SUITE, POINT, SCALAR> Aggregator<SUITE, POINT, SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    // // VerifyDeal analyzes the deal and returns an error if it's incorrect. If
    // // inclusion is true, it also returns an error if it the second time this struct
    // // analyzes a Deal.
    // func (a *aggregator) VerifyDeal(d *Deal, inclusion bool) error {
    // 	if a.deal != nil && inclusion {
    // 		return errDealAlreadyProcessed

    // 	}
    // 	if a.deal == nil {
    // 		a.commits = d.Commitments
    // 		a.sid = d.SessionID
    // 		a.deal = d
    // 	}

    // 	if !validT(int(d.T), a.verifiers) {
    // 		return errors.New("vss: invalid t received in Deal")
    // 	}

    // 	if !bytes.Equal(a.sid, d.SessionID) {
    // 		return errors.New("vss: find different sessionIDs from Deal")
    // 	}

    // 	fi := d.SecShare
    // 	gi := d.RndShare
    // 	if fi.I != gi.I {
    // 		return errors.New("vss: not the same index for f and g share in Deal")
    // 	}
    // 	if fi.I < 0 || fi.I >= len(a.verifiers) {
    // 		return errors.New("vss: index out of bounds in Deal")
    // 	}
    // 	// compute fi * G + gi * H
    // 	fig := a.suite.Point().Base().Mul(fi.V, nil)
    // 	H := deriveH(a.suite, a.verifiers)
    // 	gih := a.suite.Point().Mul(gi.V, H)
    // 	ci := a.suite.Point().Add(fig, gih)

    // 	commitPoly := share.NewPubPoly(a.suite, nil, d.Commitments)

    // 	pubShare := commitPoly.Eval(fi.I)
    // 	if !ci.Equal(pubShare.V) {
    // 		return errors.New("vss: share does not verify against commitments in Deal")
    // 	}
    // 	return nil
    // }

    // // cleanVerifiers checks the aggregator's response array and creates a StatusComplaint
    // // response for all verifiers who have no response in the array.
    // func (a *aggregator) cleanVerifiers() {
    // 	for i := range a.verifiers {
    // 		if _, ok := a.responses[uint32(i)]; !ok {
    // 			a.responses[uint32(i)] = &Response{
    // 				SessionID: a.sid,
    // 				Index:     uint32(i),
    // 				Approved:  false,
    // 			}
    // 		}
    // 	}
    // }

    // func (a *aggregator) verifyResponse(r *Response) error {
    // 	if !bytes.Equal(r.SessionID, a.sid) {
    // 		return errors.New("vss: receiving inconsistent sessionID in response")
    // 	}

    // 	pub, ok := findPub(a.verifiers, r.Index)
    // 	if !ok {
    // 		return errors.New("vss: index out of bounds in response")
    // 	}

    // 	if err := schnorr.Verify(a.suite, pub, r.Hash(a.suite), r.Signature); err != nil {
    // 		return err
    // 	}

    // 	return a.addResponse(r)
    // }

    // func (a *aggregator) verifyJustification(j *Justification) error {
    // 	if _, ok := findPub(a.verifiers, j.Index); !ok {
    // 		return errors.New("vss: index out of bounds in justification")
    // 	}
    // 	r, ok := a.responses[j.Index]
    // 	if !ok {
    // 		return errors.New("vss: no complaints received for this justification")
    // 	}
    // 	if r.Approved {
    // 		return errors.New("vss: justification received for an approval")
    // 	}

    // 	if err := a.VerifyDeal(j.Deal, false); err != nil {
    // 		// if one response is bad, flag the dealer as malicious
    // 		a.badDealer = true
    // 		return err
    // 	}
    // 	r.Approved = true
    // 	return nil
    // }

    // func (a *aggregator) addResponse(r *Response) error {
    // 	if _, ok := findPub(a.verifiers, r.Index); !ok {
    // 		return errors.New("vss: index out of bounds in Complaint")
    // 	}
    // 	if _, ok := a.responses[r.Index]; ok {
    // 		return errors.New("vss: already existing response from same origin")
    // 	}
    // 	a.responses[r.Index] = r
    // 	return nil
    // }

    // // EnoughApprovals returns true if enough verifiers have sent their approval for
    // // the deal they received.
    // func (a *aggregator) EnoughApprovals() bool {
    // 	var app int
    // 	for _, r := range a.responses {
    // 		if r.Approved {
    // 			app++
    // 		}
    // 	}
    // 	return app >= a.t
    // }

    /// deal_certified returns true if there has been less than t complaints, all
    /// Justifications were correct and if EnoughApprovals() returns true.
    pub fn deal_certified(&self) -> bool {
        // // a can be nil if we're calling it before receiving a deal
        // if a == nil {
        // 	return false
        // }

        // var verifiersUnstable int
        // // Check either a StatusApproval or StatusComplaint for all known verifiers
        // // i.e. make sure all verifiers are either timed-out or OK.
        // for i := range a.verifiers {
        // 	if _, ok := a.responses[uint32(i)]; !ok {
        // 		verifiersUnstable++
        // 	}
        // }

        // tooMuchComplaints := verifiersUnstable > 0 || a.badDealer
        // return a.EnoughApprovals() && !tooMuchComplaints
        todo!()
    }

    // // UnsafeSetResponseDKG is an UNSAFE bypass method to allow DKG to use VSS
    // // that works on basis of approval only.
    // func (a *aggregator) UnsafeSetResponseDKG(idx uint32, approval bool) {
    // 	r := &Response{
    // 		SessionID: a.sid,
    // 		Index:     uint32(idx),
    // 		Approved:  approval,
    // 	}

    // 	a.addResponse(r)
    // }
}

/// minimum_t returns the minimum safe T that is proven to be secure with this
/// protocol. It expects n, the total number of participants.
/// WARNING: Setting a lower T could make
/// the whole protocol insecure. Setting a higher T only makes it harder to
/// reconstruct the secret.
pub fn minimum_t(n: usize) -> usize {
    return (n + 1) / 2;
}

fn validT<POINT, SCALAR>(t: usize, verifiers: &Vec<POINT>) -> bool
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
    return t >= 2 && t <= verifiers.len() && (t as u32) as i64 == t as i64;
}

fn deriveH<SUITE, POINT, SCALAR>(suite: SUITE, verifiers: &Vec<POINT>) -> POINT
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    let mut b = vec![];
    for v in verifiers {
        v.MarshalTo(&mut b).unwrap();
    }
    let base = suite.point().pick(&mut suite.xof(Some(&b)));
    base
}

fn findPub<SCALAR: Scalar, POINT: Point<SCALAR>>(
    verifiers: Vec<POINT>,
    idx: usize,
) -> Option<POINT> {
    verifiers.get(idx).map(|x| x.clone())
}

fn sessionID<SCALAR, POINT, SUITE>(
    suite: &SUITE,
    dealer: &POINT,
    verifiers: &Vec<POINT>,
    commitments: &Vec<POINT>,
    t: usize,
) -> Result<Vec<u8>>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    let mut h = suite.hash();
    dealer.MarshalTo(&mut h)?;

    for v in verifiers {
        v.MarshalTo(&mut h)?;
    }

    for c in commitments {
        c.MarshalTo(&mut h)?;
    }

    h.write_u32::<LittleEndian>(t as u32)?;

    Ok(h.finalize().to_vec())
}

// // Hash returns the Hash representation of the Response
// func (r *Response) Hash(s Suite) []byte {
// 	h := s.Hash()
// 	_, _ = h.Write([]byte("response"))
// 	_, _ = h.Write(r.SessionID)
// 	_ = binary.Write(h, binary.LittleEndian, r.Index)
// 	_ = binary.Write(h, binary.LittleEndian, r.Approved)
// 	return h.Sum(nil)
// }

// func (d *Deal) decode(s Suite, buff []byte) error {
// 	constructors := make(protobuf.Constructors)
// 	var point kyber.Point
// 	var secret kyber.Scalar
// 	constructors[reflect.TypeOf(&point).Elem()] = func() interface{} { return s.Point() }
// 	constructors[reflect.TypeOf(&secret).Elem()] = func() interface{} { return s.Scalar() }
// 	return protobuf.DecodeWithConstructors(buff, d, constructors)
// }

// // Hash returns the hash of a Justification.
// func (j *Justification) Hash(s Suite) []byte {
// 	h := s.Hash()
// 	_, _ = h.Write([]byte("justification"))
// 	_, _ = h.Write(j.SessionID)
// 	_ = binary.Write(h, binary.LittleEndian, j.Index)
// 	buff, _ := protobuf.Encode(j.Deal)
// 	_, _ = h.Write(buff)
// 	return h.Sum(nil)
// }

/// RecoverSecret recovers the secret shared by a Dealer by gathering at least t
/// Deals from the verifiers. It returns an error if there is not enough Deals or
/// if all Deals don't have the same SessionID.
pub fn RecoverSecret<SCALAR, POINT, SUITE>(
    suite: SUITE,
    deals: Vec<Deal<SCALAR, POINT>>,
    n: usize,
    t: usize,
) -> Result<SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    // shares := make([]*share.PriShare, len(deals))
    // for i, deal := range deals {
    // 	// all sids the same
    // 	if bytes.Equal(deal.SessionID, deals[0].SessionID) {
    // 		shares[i] = deal.SecShare
    // 	} else {
    // 		return nil, errors.New("vss: all deals need to have same session id")
    // 	}
    // }
    // return share.RecoverSecret(suite, shares, t, n)
    todo!()
}
