// Package vss implements the verifiable secret sharing scheme from the
// paper "Provably Secure Distributed Schnorr Signatures and a (t, n) Threshold
// Scheme for Implicit Certificates".
// VSS enables a dealer to share a secret securely and verifiably among n
// participants out of which at least t are required for its reconstruction.
// The verifiability of the process prevents a
// malicious dealer from influencing the outcome to his advantage as each
// verifier can check the validity of the received share. The protocol has the
// following steps:
//
//   1) The dealer send a Deal to every verifiers using `Deals()`. Each deal must
//   be sent securely to one verifier whose public key is at the same index than
//   the index of the Deal.
//
//   2) Each verifier processes the Deal with `ProcessDeal`.
//   This function returns a Response which can be twofold:
//   - an approval, to confirm a correct deal
//   - a complaint to announce an incorrect deal notifying others that the
//     dealer might be malicious.
//	 All Responses must be broadcasted to every verifiers and the dealer.
//   3) The dealer can respond to each complaint by a justification revealing the
//   share he originally sent out to the accusing verifier. This is done by
//   calling `ProcessResponse` on the `Dealer`.
//   4) The verifiers refuse the shared secret and abort the protocol if there
//   are at least t complaints OR if a Justification is wrong. The verifiers
//   accept the shared secret if there are at least t approvals at which point
//   any t out of n verifiers can reveal their shares to reconstruct the shared
//   secret.

use core::fmt;
use std::collections::HashMap;
use std::marker::PhantomData;

use crate::encoding::{self, BinaryMarshaler};
use crate::group::{HashFactory, PointCanCheckCanonicalAndSmallOrder, ScalarCanCheckCanonical};
use crate::share::poly::{NewPriPoly, PriShare};
use crate::share::vss::rabin::dh::AEAD;
use crate::sign::schnorr;
use crate::Scalar;
use crate::{Group, Point, Random, XOFFactory};

use anyhow::__private::kind::TraitKind;
use anyhow::{bail, Error, Ok, Result};
use byteorder::{LittleEndian, WriteBytesExt};
use digest::DynDigest;
use serde::Serialize;
use std::ops::{Deref, DerefMut};

use super::dh::{context, dhExchange, AES_NONCE_LENGTH};

/// Suite defines the capabilities required by the vss package.
pub trait Suite<SCALAR, POINT>:
    Group<SCALAR, POINT> + HashFactory + XOFFactory + Random + Clone + Copy
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
}

/// Dealer encapsulates for creating and distributing the shares and for
/// replying to any Responses.
pub struct Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    suite: SUITE,
    // reader: STREAM,
    // long is the longterm key of the Dealer
    pub(crate) long: SCALAR,
    pub(crate) pubb: POINT,
    pub secret: SCALAR,
    secret_commits: Vec<POINT>,
    pub(crate) verifiers: Vec<POINT>,
    hkdf_context: Vec<u8>,
    // threshold of shares that is needed to reconstruct the secret
    t: usize,
    // sessionID is a unique identifier for the whole session of the scheme
    session_id: Vec<u8>,
    // list of deals this Dealer has generated
    deals: Vec<Deal<SCALAR, POINT, SUITE>>,
    aggregator: Aggregator<SUITE, POINT, SCALAR>,
}

impl<SCALAR, SUITE, POINT> Deref for Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    type Target = Aggregator<SUITE, POINT, SCALAR>;

    fn deref(&self) -> &Self::Target {
        &self.aggregator
    }
}

impl<SCALAR, SUITE, POINT> DerefMut for Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.aggregator
    }
}

/// Deal encapsulates the verifiable secret share and is sent by the dealer to a verifier.
#[derive(Serialize)]
pub struct Deal<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
    _phantom: PhantomData<(SCALAR, SUITE)>,

    /// Unique session identifier for this protocol run
    session_id: Vec<u8>,
    /// Private share generated by the dealer
    sec_share: PriShare<SCALAR>,
    /// Random share generated by the dealer
    rnd_share: PriShare<SCALAR>,
    /// Threshold used for this secret sharing run
    t: usize,
    // Commitments are the coefficients used to verify the shares against
    commitments: Vec<POINT>,
}

impl<SCALAR, POINT, SUITE> Deal<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    fn decode(s: SUITE, buff: &[u8]) -> Result<Deal<SCALAR, POINT, SUITE>> {
        // constructors := make(protobuf.Constructors)
        // var point kyber.Point
        // var secret kyber.Scalar
        // constructors[reflect.TypeOf(&point).Elem()] = func() interface{} { return s.Point() }
        // constructors[reflect.TypeOf(&secret).Elem()] = func() interface{} { return s.Scalar() }
        // return protobuf.DecodeWithConstructors(buff, d, constructors)
        todo!()
    }
}

impl<SCALAR, POINT, SUITE> BinaryMarshaler for Deal<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar + Serialize,
    POINT: Point<SCALAR> + Serialize,
    SUITE: Suite<SCALAR, POINT>,
{
    fn marshal_binary(&self) -> Result<Vec<u8>> {
        encoding::marshal_binary(self)
    }
}

/// EncryptedDeal contains the deal in a encrypted form only decipherable by the
/// correct recipient. The encryption is performed in a similar manner as what is
/// done in TLS. The dealer generates a temporary key pair, signs it with its
/// longterm secret key.
pub struct EncryptedDeal<POINT, SCALAR>
where
    POINT: Point<SCALAR>,
    SCALAR: Scalar,
{
    _phantom: PhantomData<SCALAR>,
    /// Ephemeral Diffie Hellman key
    dhkey: POINT,
    /// Signature of the DH key by the longterm key of the dealer
    signature: Vec<u8>,
    /// Nonce used for the encryption
    nonce: Vec<u8>,
    /// AEAD encryption of the deal marshalled by protobuf
    cipher: Vec<u8>,
}

/// Response is sent by the verifiers to all participants and holds each
/// individual validation or refusal of a Deal.
#[derive(Clone, Debug)]
pub struct Response {
    /// SessionID related to this run of the protocol
    pub session_id: Vec<u8>,
    /// Index of the verifier issuing this Response
    pub index: u32,
    /// Approved is true if the Response is valid
    pub approved: bool,
    /// Signature over the whole packet
    pub signature: Vec<u8>,
}

impl Default for Response {
    fn default() -> Self {
        Self {
            session_id: Default::default(),
            index: Default::default(),
            approved: Default::default(),
            signature: Default::default(),
        }
    }
}

impl Response {
    /// Hash returns the Hash representation of the Response
    fn hash<SCALAR, POINT, SUITE>(&self, s: SUITE) -> Result<Vec<u8>>
    where
        SCALAR: Scalar,
        POINT: Point<SCALAR>,
        SUITE: Suite<SCALAR, POINT>,
    {
        let mut h = s.hash();
        h.write("response".as_bytes());
        h.write(&self.session_id);
        // binary.Write(h, binary.LittleEndian, self.index);
        // binary.Write(h, binary.LittleEndian, self.approved);
        // return h.Sum(nil)
        todo!()
    }
}

/// Justification is a message that is broadcasted by the Dealer in response to
/// a Complaint. It contains the original Complaint as well as the shares
/// distributed to the complainer.
pub struct Justification<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    /// SessionID related to the current run of the protocol
    session_id: Vec<u8>,
    /// Index of the verifier who issued the Complaint,i.e. index of this Deal
    index: u32,
    /// Deal in cleartext
    deal: Deal<SCALAR, POINT, SUITE>,
    /// Signature over the whole packet
    signature: Vec<u8>,
}

/// NewDealer returns a Dealer capable of leading the secret sharing scheme. It
/// does not have to be trusted by other Verifiers. The security parameter t is
/// the number of shares required to reconstruct the secret. It is HIGHLY
/// RECOMMENDED to use a threshold higher or equal than what the method
/// MinimumT() returns, otherwise it breaks the security assumptions of the whole
/// scheme. It returns an error if the t is inferior or equal to 2.
pub fn NewDealer<SCALAR, POINT, SUITE>(
    suite: SUITE,
    longterm: SCALAR,
    secret: SCALAR,
    verifiers: Vec<POINT>,
    t: usize,
) -> Result<Dealer<SCALAR, SUITE, POINT>>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
    // STREAM: Stream,
{
    if !validT(t, &verifiers) {
        bail!("dealer: t {} invalid", t);
    }

    let H = deriveH(suite, &verifiers);
    let f = NewPriPoly(suite, t, Some(secret.clone()), suite.random_stream());
    let g = NewPriPoly(suite, t, None, suite.random_stream());
    let d_pubb = suite.point().mul(&longterm, None);

    // Compute public polynomial coefficients
    let F = f.Commit(suite.point().base());
    let (_, secret_commits) = F.Info();
    let G = g.Commit(H);

    let C = F.Add(&G)?;
    let (_, commitments) = C.Info();

    let session_id = sessionID(&suite, &d_pubb, &verifiers, &commitments, t)?;

    let aggregator = newAggregator(
        suite,
        d_pubb.clone(),
        verifiers.clone(),
        commitments.clone(),
        t,
        &session_id,
    );
    // C = F + G
    let mut deals: Vec<Deal<SCALAR, POINT, SUITE>> = vec![];
    for i in 0..verifiers.len() {
        let fi = f.Eval(i);
        let gi = g.Eval(i);
        deals.push(Deal {
            session_id: session_id.clone(),
            sec_share: fi,
            rnd_share: gi,
            commitments: commitments.clone(),
            t: t,
            _phantom: PhantomData,
        });
    }

    let hkdf_context = context(&suite, &d_pubb, &verifiers).to_vec();

    Ok(Dealer {
        suite: suite,
        long: longterm,
        secret: secret,
        verifiers: verifiers,
        pubb: d_pubb,
        secret_commits,
        hkdf_context,
        t,
        session_id,
        aggregator,
        deals,
    })
}

// // PlaintextDeal returns the plaintext version of the deal destined for peer i.
// // Use this only for testing.
// func (d *Dealer) PlaintextDeal(i int) (*Deal, error) {
// 	if i >= len(d.deals) {
// 		return nil, errors.New("dealer: PlaintextDeal given wrong index")
// 	}
// 	return d.deals[i], nil
// }

impl<SCALAR, SUITE, POINT> Dealer<SCALAR, SUITE, POINT>
where
    SCALAR: Scalar + Serialize,
    POINT: Point<SCALAR> + Serialize,
    SUITE: Suite<SCALAR, POINT>,
{
    /// EncryptedDeal returns the encryption of the deal that must be given to the
    /// verifier at index i.
    /// The dealer first generates a temporary Diffie Hellman key, signs it using its
    /// longterm key, and computes the shared key depending on its longterm and
    /// ephemeral key and the verifier's public key.
    /// This shared key is then fed into a HKDF whose output is the key to a AEAD
    /// (AES256-GCM) scheme to encrypt the deal.
    pub fn EncryptedDeal(&self, i: usize) -> Result<EncryptedDeal<POINT, SCALAR>> {
        let vPub = findPub(&self.verifiers, i)
            .ok_or(Error::msg("dealer: wrong index to generate encrypted deal"))?;
        // gen ephemeral key
        // let dhSecret = self.suite.scalar().pick(&mut self.suite.random_stream());
        let dhSecret = self.suite.scalar().set_int64(0);
        let dhPublic = self.suite.point().mul(&dhSecret, None);
        // signs the public key
        // let dhPublicBuff = dhPublic.marshal_binary()?;
        let dhPublicBuff = vec![1, 2, 3, 4, 5];
        let signature = schnorr::Sign(self.suite, self.long.clone(), &dhPublicBuff)?;

        // AES128-GCM
        let pre = dhExchange(self.suite, dhSecret, vPub);
        let gcm = AEAD::new(pre, &self.hkdf_context)?;

        let nonce = [0u8; AEAD::nonce_size()];
        // let dealBuff = protobuf.Encode(self.deals[i])?;
        // let deal_buf = self.deals[i].marshal_binary()?;
        let deal_buf = vec![1, 2, 3, 4, 5];
        let encrypted = gcm.seal(None, &nonce, &deal_buf, Some(&self.hkdf_context))?;
        return Ok(EncryptedDeal {
            dhkey: dhPublic,
            signature,
            nonce: nonce.to_vec(),
            cipher: encrypted,
            _phantom: PhantomData,
        });
    }

    /// encrypted_deals calls `EncryptedDeal` for each index of the verifier and
    /// returns the list of encrypted deals. Each index in the returned slice
    /// corresponds to the index in the list of verifiers.
    pub fn encrypted_deals(&self) -> Result<Vec<EncryptedDeal<POINT, SCALAR>>> {
        // deals := make([]*EncryptedDeal, len(d.verifiers));
        let mut deals = vec![];
        // var err error
        for i in 0..self.verifiers.len() {
            let deal = self.EncryptedDeal(i)?;
            deals.push(deal);
        }
        Ok(deals)
    }

    /// process_response analyzes the given Response. If it's a valid complaint, then
    /// it returns a Justification. This Justification must be broadcasted to every
    /// participants. If it's an invalid complaint, it returns an error about the
    /// complaint. The verifiers will also ignore an invalid Complaint.
    pub fn process_response(
        &self,
        _r: &Response,
    ) -> Result<Option<Justification<SCALAR, POINT, SUITE>>> {
        // if err := d.verifyResponse(r); err != nil {
        // 	return nil, err
        // }
        // if r.Approved {
        // 	return nil, nil
        // }

        // j := &Justification{
        // 	SessionID: d.sessionID,
        // 	// index is guaranteed to be good because of d.verifyResponse before
        // 	Index: r.Index,
        // 	Deal:  d.deals[int(r.Index)],
        // }
        // sig, err := schnorr.Sign(d.suite, d.long, j.Hash(d.suite))
        // if err != nil {
        // 	return nil, err
        // }
        // j.Signature = sig
        // return j, nil
        todo!()
    }

    // // SecretCommit returns the commitment of the secret being shared by this
    // // dealer. This function is only to be called once the deal has enough approvals
    // // and is verified otherwise it returns nil.
    // func (d *Dealer) SecretCommit() kyber.Point {
    // 	if !d.EnoughApprovals() || !d.DealCertified() {
    // 		return nil
    // 	}
    // 	return d.suite.Point().Mul(d.secret, nil)
    // }

    // // Commits returns the commitments of the coefficient of the secret polynomial
    // // the Dealer is sharing.
    // func (d *Dealer) Commits() []kyber.Point {
    // 	if !d.EnoughApprovals() || !d.DealCertified() {
    // 		return nil
    // 	}
    // 	return d.secretCommits
    // }

    // // Key returns the longterm key pair used by this Dealer.
    // func (d *Dealer) Key() (secret kyber.Scalar, public kyber.Point) {
    // 	return d.long, d.pub
    // }

    // // SessionID returns the current sessionID generated by this dealer for this
    // // protocol run.
    // func (d *Dealer) SessionID() []byte {
    // 	return d.sessionID
    // }

    // // SetTimeout tells this dealer to consider this moment the maximum time limit.
    // // it calls cleanVerifiers which will take care of all Verifiers who have not
    // // responded until now.
    // func (d *Dealer) SetTimeout() {
    // 	d.aggregator.cleanVerifiers()
    // }

    // /// deal_certified returns true if there has been less than t complaints, all
    // /// Justifications were correct and if EnoughApprovals() returns true.
    // pub fn deal_certified(&self) -> bool {
    //     self.aggregator.deal_certified()
    // }
}

/// Verifier receives a Deal from a Dealer, can reply with a Complaint, and can
/// collaborate with other Verifiers to reconstruct a secret.
pub struct Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    suite: SUITE,
    longterm: SCALAR,
    pubb: POINT,
    dealer: POINT,
    pub(crate) index: usize,
    verifiers: Vec<POINT>,
    hkdfContext: Vec<u8>,
    pub(crate) aggregator: Option<Aggregator<SUITE, POINT, SCALAR>>,
}

/// NewVerifier returns a Verifier out of:
/// - its longterm secret key
/// - the longterm dealer public key
/// - the list of public key of verifiers. The list MUST include the public key
/// of this Verifier also.
/// The security parameter t of the secret sharing scheme is automatically set to
/// a default safe value. If a different t value is required, it is possible to set
/// it with `verifier.SetT()`.
pub fn NewVerifier<SCALAR, POINT, SUITE>(
    suite: SUITE,
    longterm: SCALAR,
    dealer_key: POINT,
    verifiers: Vec<POINT>,
) -> Result<Verifier<SCALAR, POINT, SUITE>>
where
    POINT: Point<SCALAR>,
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
{
    let p = suite.point();
    let pubb = p.mul(&longterm, None);
    let mut ok = false;
    let mut index = 0;
    for (i, v) in verifiers.iter().enumerate() {
        if v.equal(&pubb) {
            ok = true;
            index = i;
            break;
        }
    }
    if !ok {
        bail!("vss: public key not found in the list of verifiers");
    }
    let c = context(&suite, &dealer_key, &verifiers);
    Ok(Verifier {
        suite,
        longterm,
        dealer: dealer_key,
        verifiers,
        pubb,
        index,
        hkdfContext: Vec::from(c),
        aggregator: None,
    })
}

impl<SCALAR, POINT, SUITE> Deref for Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    SUITE: Suite<SCALAR, POINT>,
    POINT: Point<SCALAR>,
{
    type Target = Aggregator<SUITE, POINT, SCALAR>;

    fn deref(&self) -> &Self::Target {
        self.aggregator.as_ref().unwrap()
    }
}

impl<SCALAR, POINT, SUITE> DerefMut for Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.aggregator.as_mut().unwrap()
    }
}

impl<SCALAR, POINT, SUITE> Verifier<SCALAR, POINT, SUITE>
where
    SCALAR: Scalar + ScalarCanCheckCanonical<SCALAR>,
    POINT: Point<SCALAR> + PointCanCheckCanonicalAndSmallOrder<SCALAR, POINT>,
    SUITE: Suite<SCALAR, POINT>,
{
    // process_encrypted_deal decrypt the deal received from the Dealer.
    // If the deal is valid, i.e. the verifier can verify its shares
    // against the public coefficients and the signature is valid, an approval
    // response is returned and must be broadcasted to every participants
    // including the dealer.
    // If the deal itself is invalid, it returns a complaint response that must be
    // broadcasted to every other participants including the dealer.
    // If the deal has already been received, or the signature generation of the
    // response failed, it returns an error without any responses.
    pub fn process_encrypted_deal(&mut self, e: &EncryptedDeal<POINT, SCALAR>) -> Result<Response> {
        let d = self.decryptDeal(e)?;
        if d.sec_share.i != self.index {
            bail!("vss: verifier got wrong index from deal");
        }

        let t = d.t;

        let sid = sessionID(
            &self.suite,
            &self.dealer,
            &self.verifiers,
            &d.commitments,
            t,
        )?;

        if self.aggregator.is_none() {
            self.aggregator = Some(newAggregator(
                self.suite,
                self.dealer.clone(),
                self.verifiers.clone(),
                d.commitments.clone(),
                t,
                &d.session_id,
            ));
        }

        let mut r = Response {
            session_id: sid,
            index: self.index as u32,
            approved: true,
            ..Default::default()
        };
        let result = self.verify_deal(&d, true);

        if let Err(err) = result {
            r.approved = false;
            match err {
                VerifyDealError::DealAlreadyProcessedError => bail!(err),
            }
        }

        r.signature = schnorr::Sign(
            self.suite,
            self.longterm.clone(),
            r.hash(self.suite)?.as_slice(),
        )?;

        self.aggregator.as_mut().unwrap().add_response(r.clone())?;
        Ok(r)
    }

    fn decryptDeal(&self, e: &EncryptedDeal<POINT, SCALAR>) -> Result<Deal<SCALAR, POINT, SUITE>> {
        let ephBuff = e.dhkey.marshal_binary()?;
        // verify signature
        schnorr::Verify(self.suite, &self.dealer, ephBuff.as_slice(), &e.signature)?;

        // compute shared key and AES526-GCM cipher
        let pre = dhExchange(self.suite, self.longterm.clone(), e.dhkey.clone());
        let gcm = AEAD::new(pre, &self.hkdfContext)?;
        let decrypted = gcm.open(
            None,
            e.nonce.as_slice().try_into().unwrap(),
            &e.cipher,
            Some(self.hkdfContext.as_slice()),
        )?;
        Deal::decode(self.suite, &decrypted)
    }

    /// ProcessResponse analyzes the given response. If it's a valid complaint, the
    /// verifier should expect to see a Justification from the Dealer. It returns an
    /// error if it's not a valid response.
    /// Call `v.DealCertified()` to check if the whole protocol is finished.
    pub fn process_response(&self, _resp: &Response) -> Result<()> {
        // v.aggregator.verifyResponse(resp)
        todo!();
    }

    /// deal returns the Deal that this verifier has received. It returns
    /// nil if the deal is not certified or there is not enough approvals.
    pub fn deal(&self) -> Option<Deal<SCALAR, POINT, SUITE>> {
        todo!()
        // if !v.EnoughApprovals() || !v.DealCertified() {
        //     return nil;
        // }
        // return v.deal;
    }

    // // ProcessJustification takes a DealerResponse and returns an error if
    // // something went wrong during the verification. If it is the case, that
    // // probably means the Dealer is acting maliciously. In order to be sure, call
    // // `v.EnoughApprovals()` and if true, `v.DealCertified()`.
    // func (v *Verifier) ProcessJustification(dr *Justification) error {
    // 	return v.aggregator.verifyJustification(dr)
    // }

    // // Key returns the longterm key pair this verifier is using during this protocol
    // // run.
    // func (v *Verifier) Key() (kyber.Scalar, kyber.Point) {
    // 	return v.longterm, v.pub
    // }

    // // Index returns the index of the verifier in the list of participants used
    // // during this run of the protocol.
    // func (v *Verifier) Index() int {
    // 	return v.index
    // }

    // // SessionID returns the session id generated by the Dealer. WARNING: it returns
    // // an nil slice if the verifier has not received the Deal yet !
    // func (v *Verifier) SessionID() []byte {
    // 	return v.sid
    // }

    /// SetTimeout tells this verifier to consider this moment the maximum time limit.
    /// it calls cleanVerifiers which will take care of all Verifiers who have not
    /// responded until now.
    pub fn SetTimeout(&self) {
        // self.aggregator.cleanVerifiers()
        todo!()
    }
}

/// Aggregator is used to collect all deals, and responses for one protocol run.
/// It brings common functionalities for both Dealer and Verifier structs.
pub struct Aggregator<SUITE, POINT, SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    _phantom: PhantomData<SCALAR>,
    suite: SUITE,
    dealer: POINT,
    verifiers: Vec<POINT>,
    commits: Vec<POINT>,

    pub(crate) responses: HashMap<u32, Response>,
    sid: Vec<u8>,
    deal: Option<Deal<SCALAR, POINT, SUITE>>,
    pub(crate) t: usize,
    pub(crate) bad_dealer: bool,
}

fn newAggregator<SCALAR, POINT, SUITE>(
    suite: SUITE,
    dealer: POINT,
    verifiers: Vec<POINT>,
    commitments: Vec<POINT>,
    t: usize,
    sid: &[u8],
) -> Aggregator<SUITE, POINT, SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    Aggregator {
        suite: suite,
        dealer: dealer,
        verifiers: verifiers,
        commits: commitments,
        t,
        sid: sid.clone().to_vec(),
        responses: HashMap::new(),
        deal: None,
        bad_dealer: false,
        _phantom: PhantomData,
    }
}

#[derive(Debug, Clone)]
enum VerifyDealError {
    DealAlreadyProcessedError,
}

impl fmt::Display for VerifyDealError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerifyDealError::DealAlreadyProcessedError => write!(f, "{}", self),
        }
    }
}

impl std::error::Error for VerifyDealError {}

#[derive(Debug, Clone)]
struct DealAlreadyProcessedError;

impl fmt::Display for DealAlreadyProcessedError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "vss: verifier already received a deal")
    }
}

impl<SUITE, POINT, SCALAR> Aggregator<SUITE, POINT, SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    /// verify_deal analyzes the deal and returns an error if it's incorrect. If
    /// inclusion is true, it also returns an error if it the second time this struct
    /// analyzes a Deal.
    fn verify_deal(
        &self,
        d: &Deal<SCALAR, POINT, SUITE>,
        inclusion: bool,
    ) -> Result<(), VerifyDealError> {
        // if a.deal != nil && inclusion {
        // 	return errDealAlreadyProcessed

        // }
        // if a.deal == nil {
        // 	a.commits = d.Commitments
        // 	a.sid = d.SessionID
        // 	a.deal = d
        // }

        // if !validT(int(d.T), a.verifiers) {
        // 	return errors.New("vss: invalid t received in Deal")
        // }

        // if !bytes.Equal(a.sid, d.SessionID) {
        // 	return errors.New("vss: find different sessionIDs from Deal")
        // }

        // fi := d.SecShare
        // gi := d.RndShare
        // if fi.I != gi.I {
        // 	return errors.New("vss: not the same index for f and g share in Deal")
        // }
        // if fi.I < 0 || fi.I >= len(a.verifiers) {
        // 	return errors.New("vss: index out of bounds in Deal")
        // }
        // // compute fi * G + gi * H
        // fig := a.suite.Point().Base().Mul(fi.V, nil)
        // H := deriveH(a.suite, a.verifiers)
        // gih := a.suite.Point().Mul(gi.V, H)
        // ci := a.suite.Point().Add(fig, gih)

        // commitPoly := share.NewPubPoly(a.suite, nil, d.Commitments)

        // pubShare := commitPoly.Eval(fi.I)
        // if !ci.Equal(pubShare.V) {
        // 	return errors.New("vss: share does not verify against commitments in Deal")
        // }
        // return nil
        todo!()
    }

    /// cleanVerifiers checks the aggregator's response array and creates a StatusComplaint
    /// response for all verifiers who have no response in the array.
    fn cleanVerifiers(&mut self) {
        for i in 0..self.verifiers.len() {
            if self.responses.contains_key(&(i as u32)) {
                self.responses.insert(
                    i as u32,
                    Response {
                        session_id: self.sid.clone(),
                        index: i as u32,
                        approved: false,
                        ..Response::default()
                    },
                );
            }
        }
    }

    // func (a *aggregator) verifyResponse(r *Response) error {
    // 	if !bytes.Equal(r.SessionID, a.sid) {
    // 		return errors.New("vss: receiving inconsistent sessionID in response")
    // 	}

    // 	pub, ok := findPub(a.verifiers, r.Index)
    // 	if !ok {
    // 		return errors.New("vss: index out of bounds in response")
    // 	}

    // 	if err := schnorr.Verify(a.suite, pub, r.Hash(a.suite), r.Signature); err != nil {
    // 		return err
    // 	}

    // 	return a.addResponse(r)
    // }

    // func (a *aggregator) verifyJustification(j *Justification) error {
    // 	if _, ok := findPub(a.verifiers, j.Index); !ok {
    // 		return errors.New("vss: index out of bounds in justification")
    // 	}
    // 	r, ok := a.responses[j.Index]
    // 	if !ok {
    // 		return errors.New("vss: no complaints received for this justification")
    // 	}
    // 	if r.Approved {
    // 		return errors.New("vss: justification received for an approval")
    // 	}

    // 	if err := a.VerifyDeal(j.Deal, false); err != nil {
    // 		// if one response is bad, flag the dealer as malicious
    // 		a.badDealer = true
    // 		return err
    // 	}
    // 	r.Approved = true
    // 	return nil
    // }

    pub fn add_response(&mut self, r: Response) -> Result<()> {
        if findPub(&self.verifiers, r.index as usize).is_none() {
            bail!("vss: index out of bounds in Complaint");
        }
        if self.responses.get(&(r.index as u32)).is_some() {
            bail!("vss: already existing response from same origin")
        }
        self.responses.insert(r.index, r);
        Ok(())
    }

    // // EnoughApprovals returns true if enough verifiers have sent their approval for
    // // the deal they received.
    // func (a *aggregator) EnoughApprovals() bool {
    // 	var app int
    // 	for _, r := range a.responses {
    // 		if r.Approved {
    // 			app++
    // 		}
    // 	}
    // 	return app >= a.t
    // }

    /// deal_certified returns true if there has been less than t complaints, all
    /// Justifications were correct and if EnoughApprovals() returns true.
    pub fn deal_certified(&self) -> bool {
        // // a can be nil if we're calling it before receiving a deal
        // if a == nil {
        // 	return false
        // }

        // var verifiersUnstable int
        // // Check either a StatusApproval or StatusComplaint for all known verifiers
        // // i.e. make sure all verifiers are either timed-out or OK.
        // for i := range a.verifiers {
        // 	if _, ok := a.responses[uint32(i)]; !ok {
        // 		verifiersUnstable++
        // 	}
        // }

        // tooMuchComplaints := verifiersUnstable > 0 || a.badDealer
        // return a.EnoughApprovals() && !tooMuchComplaints
        todo!()
    }

    // // UnsafeSetResponseDKG is an UNSAFE bypass method to allow DKG to use VSS
    // // that works on basis of approval only.
    // func (a *aggregator) UnsafeSetResponseDKG(idx uint32, approval bool) {
    // 	r := &Response{
    // 		SessionID: a.sid,
    // 		Index:     uint32(idx),
    // 		Approved:  approval,
    // 	}

    // 	a.addResponse(r)
    // }
}

/// minimum_t returns the minimum safe T that is proven to be secure with this
/// protocol. It expects n, the total number of participants.
/// WARNING: Setting a lower T could make
/// the whole protocol insecure. Setting a higher T only makes it harder to
/// reconstruct the secret.
pub fn minimum_t(n: usize) -> usize {
    return (n + 1) / 2;
}

fn validT<POINT, SCALAR>(t: usize, verifiers: &Vec<POINT>) -> bool
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
{
    return t >= 2 && t <= verifiers.len() && (t as u32) as i64 == t as i64;
}

fn deriveH<SUITE, POINT, SCALAR>(suite: SUITE, verifiers: &Vec<POINT>) -> POINT
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    let mut b = vec![];
    for v in verifiers {
        v.marshal_to(&mut b).unwrap();
    }
    let base = suite.point().pick(&mut suite.xof(Some(&b)));
    base
}

fn findPub<SCALAR: Scalar, POINT: Point<SCALAR>>(
    verifiers: &Vec<POINT>,
    idx: usize,
) -> Option<POINT> {
    verifiers.get(idx).map(|x| x.clone())
}

fn sessionID<SCALAR, POINT, SUITE>(
    suite: &SUITE,
    dealer: &POINT,
    verifiers: &Vec<POINT>,
    commitments: &Vec<POINT>,
    t: usize,
) -> Result<Vec<u8>>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    let mut h = suite.hash();
    dealer.marshal_to(&mut h)?;

    for v in verifiers {
        v.marshal_to(&mut h)?;
    }

    for c in commitments {
        c.marshal_to(&mut h)?;
    }

    h.write_u32::<LittleEndian>(t as u32)?;

    Ok(h.finalize().to_vec())
}

// // Hash returns the hash of a Justification.
// func (j *Justification) Hash(s Suite) []byte {
// 	h := s.Hash()
// 	_, _ = h.Write([]byte("justification"))
// 	_, _ = h.Write(j.SessionID)
// 	_ = binary.Write(h, binary.LittleEndian, j.Index)
// 	buff, _ := protobuf.Encode(j.Deal)
// 	_, _ = h.Write(buff)
// 	return h.Sum(nil)
// }

/// RecoverSecret recovers the secret shared by a Dealer by gathering at least t
/// Deals from the verifiers. It returns an error if there is not enough Deals or
/// if all Deals don't have the same SessionID.
pub fn RecoverSecret<SCALAR, POINT, SUITE>(
    _suite: SUITE,
    _deals: Vec<Deal<SCALAR, POINT, SUITE>>,
    _n: usize,
    _t: usize,
) -> Result<SCALAR>
where
    SCALAR: Scalar,
    POINT: Point<SCALAR>,
    SUITE: Suite<SCALAR, POINT>,
{
    // shares := make([]*share.PriShare, len(deals))
    // for i, deal := range deals {
    // 	// all sids the same
    // 	if bytes.Equal(deal.SessionID, deals[0].SessionID) {
    // 		shares[i] = deal.SecShare
    // 	} else {
    // 		return nil, errors.New("vss: all deals need to have same session id")
    // 	}
    // }
    // return share.RecoverSecret(suite, shares, t, n)
    todo!()
}
