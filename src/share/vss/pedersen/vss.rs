use core::{fmt, ops::Deref};
use std::{collections::HashMap, io::Write, ops::DerefMut};

use byteorder::{LittleEndian, WriteBytesExt};
use digest::Digest;
use serde::{Deserialize, Serialize};

use crate::{
    dh::{AEAD, NONCE_SIZE},
    encoding::{self, unmarshal_binary, BinaryMarshaler, Marshaling, MarshallingError},
    group::{PointCanCheckCanonicalAndSmallOrder, ScalarCanCheckCanonical},
    share::{
        self,
        poly::{new_pri_poly, PriShare},
        vss::suite::Suite,
    },
    sign::schnorr,
    Point, Scalar,
};
/// Package vss implements the verifiable secret sharing scheme from
/// "Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing"
/// by Torben Pryds Pedersen.
/// https://link.springer.com/content/pdf/10.1007/3-540-46766-1_9.pdf

/// Dealer encapsulates for creating and distributing the shares and for
/// replying to any Responses.
#[derive(Clone)]
pub struct Dealer<SUITE: Suite> {
    suite: SUITE,
    // reader: STREAM,
    // long is the longterm key of the Dealer
    pub(crate) long: <SUITE::POINT as Point>::SCALAR,
    pub(crate) pubb: SUITE::POINT,
    pub secret: <SUITE::POINT as Point>::SCALAR,
    secret_commits: Vec<SUITE::POINT>,
    secret_poly: share::poly::PriPoly<SUITE>,
    pub(crate) verifiers: Vec<SUITE::POINT>,
    hkdf_context: Vec<u8>,
    // threshold of shares that is needed to reconstruct the secret
    t: usize,
    // sessionID is a unique identifier for the whole session of the scheme
    session_id: Vec<u8>,
    // list of deals this Dealer has generated
    pub(crate) deals: Vec<Deal<SUITE>>,
    pub(crate) aggregator: Aggregator<SUITE>,
}

impl<SUITE: Suite> Deref for Dealer<SUITE> {
    type Target = Aggregator<SUITE>;

    fn deref(&self) -> &Self::Target {
        &self.aggregator
    }
}

impl<SUITE: Suite> DerefMut for Dealer<SUITE> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.aggregator
    }
}

impl<SUITE: Suite> Default for Dealer<SUITE> {
    fn default() -> Self {
        Self {
            suite: Default::default(),
            long: Default::default(),
            pubb: Default::default(),
            secret: Default::default(),
            secret_commits: Default::default(),
            secret_poly: Default::default(),
            verifiers: Default::default(),
            hkdf_context: Default::default(),
            t: Default::default(),
            session_id: Default::default(),
            deals: Default::default(),
            aggregator: Default::default(),
        }
    }
}

/// Deal encapsulates the verifiable secret share and is sent by the dealer to a verifier.
#[derive(Serialize, Deserialize, Clone)]
pub struct Deal<SUITE: Suite> {
    /// Unique session identifier for this protocol run
    pub(crate) session_id: Vec<u8>,
    /// Private share generated by the dealer
    pub(crate) sec_share: PriShare<<SUITE::POINT as Point>::SCALAR>,
    /// Threshold used for this secret sharing run
    pub(crate) t: usize,
    // Commitments are the coefficients used to verify the shares against
    pub(crate) commitments: Vec<SUITE::POINT>,
}

impl<SUITE: Suite> Default for Deal<SUITE> {
    fn default() -> Self {
        Self {
            session_id: Default::default(),
            sec_share: Default::default(),
            t: Default::default(),
            commitments: Default::default(),
        }
    }
}

impl<SUITE: Suite> Deal<SUITE> {
    fn decode(buff: &[u8]) -> anyhow::Result<Deal<SUITE>> {
        let mut d = Deal::default();
        unmarshal_binary(&mut d, buff)?;
        Ok(d)
    }
}

impl<SUITE: Suite> BinaryMarshaler for Deal<SUITE> {
    fn marshal_binary(&self) -> Result<Vec<u8>, MarshallingError> {
        encoding::marshal_binary(self)
    }
}

/// EncryptedDeal contains the deal in a encrypted form only decipherable by the
/// correct recipient. The encryption is performed in a similar manner as what is
/// done in TLS. The dealer generates a temporary key pair, signs it with its
/// longterm secret key.
#[derive(Clone, Serialize)]
pub struct EncryptedDeal<POINT: Point> {
    /// Ephemeral Diffie Hellman key
    pub(crate) dhkey: POINT,
    /// Signature of the DH key by the longterm key of the dealer
    pub(crate) signature: Vec<u8>,
    /// Nonce used for the encryption
    nonce: Vec<u8>,
    /// AEAD encryption of the deal marshalled by protobuf
    pub(crate) cipher: Vec<u8>,
}

/// Response is sent by the verifiers to all participants and holds each
/// individual validation or refusal of a Deal.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct Response {
    /// SessionID related to this run of the protocol
    pub session_id: Vec<u8>,
    /// Index of the verifier issuing this Response
    pub index: u32,
    /// false = NO APPROVAL == Complaint , true = APPROVAL
    pub status: bool,
    /// Signature over the whole packet
    pub signature: Vec<u8>,
}

impl Response {
    /// Hash returns the Hash representation of the Response
    pub fn hash<SUITE: Suite>(&self, s: &SUITE) -> anyhow::Result<Vec<u8>> {
        let mut h = s.hash();
        h.write_all("response".as_bytes())?;
        h.write_all(&self.session_id)?;
        h.write_u32::<LittleEndian>(self.index)?;
        h.write_u32::<LittleEndian>(self.status as u32)?;
        Ok(h.finalize().to_vec())
    }
}

/// StatusComplaint is a constant value meaning that a verifier issues
/// a Complaint against its Dealer.
pub const STATUS_COMPLAINT: bool = false;
/// StatusApproval is a constant value meaning that a verifier agrees with
/// the share it received.
pub const STATUS_APPROVAL: bool = true;

/// Justification is a message that is broadcasted by the Dealer in response to
/// a Complaint. It contains the original Complaint as well as the shares
/// distributed to the complainer.
#[derive(Clone)]
pub struct Justification<SUITE: Suite> {
    /// SessionID related to the current run of the protocol
    pub(crate) session_id: Vec<u8>,
    /// Index of the verifier who issued the Complaint,i.e. index of this Deal
    pub(crate) index: u32,
    /// Deal in cleartext
    pub(crate) deal: Deal<SUITE>,
    /// Signature over the whole packet
    pub(crate) signature: Vec<u8>,
}

impl<SUITE: Suite> Justification<SUITE> {
    /// Hash returns the hash of a Justification.
    fn hash(self, s: SUITE) -> anyhow::Result<Vec<u8>> {
        let mut h = s.hash();
        h.update("justification".as_bytes());
        h.update(&self.session_id);

        h.write_u32::<LittleEndian>(self.index)?;
        let buff = self.deal.marshal_binary()?;
        h.update(&buff);

        Ok(h.finalize().to_vec())
    }
}

/// NewDealer returns a Dealer capable of leading the secret sharing scheme. It
/// does not have to be trusted by other Verifiers. The security parameter t is
/// the number of shares required to reconstruct the secret. It is HIGHLY
/// RECOMMENDED to use a threshold higher or equal than what the method
/// MinimumT() returns, otherwise it breaks the security assumptions of the whole
/// scheme. It returns an error if the t is inferior or equal to 2.
pub fn new_dealer<SUITE: Suite>(
    suite: SUITE,
    longterm: <SUITE::POINT as Point>::SCALAR,
    secret: <SUITE::POINT as Point>::SCALAR,
    verifiers: &[SUITE::POINT],
    t: usize,
) -> anyhow::Result<Dealer<SUITE>> {
    if !valid_t(t, verifiers) {
        anyhow::bail!("dealer: t {} invalid", t);
    }
    // 	d.t = t

    let f = new_pri_poly(suite, t, Some(secret.clone()), suite.random_stream());
    let d_pubb = suite.point().mul(&longterm, None);

    // Compute public polynomial coefficients
    let f_caps = f.commit(Some(&suite.point().base()));
    let (_, secret_commits) = f_caps.info();

    let session_id = session_id(&suite, &d_pubb, verifiers, &secret_commits, t)?;

    let aggregator = new_aggregator(&suite, &d_pubb, verifiers, &secret_commits, t, &session_id);

    // C = F + G
    let mut deals: Vec<Deal<SUITE>> = Vec::with_capacity(verifiers.len());
    for i in 0..verifiers.len() {
        let fi = f.eval(i);
        deals.push(Deal {
            session_id: session_id.clone(),
            sec_share: fi,
            commitments: secret_commits.clone(),
            t,
        });
    }

    let hkdf_context = context(&suite, &d_pubb, verifiers).to_vec();
    Ok(Dealer {
        suite,
        long: longterm,
        secret,
        verifiers: verifiers.to_vec(),
        pubb: d_pubb,
        secret_commits,
        secret_poly: f,
        hkdf_context,
        t,
        session_id,
        aggregator,
        deals,
    })
}

impl<SUITE: Suite> Dealer<SUITE>
where
    SUITE::POINT: PointCanCheckCanonicalAndSmallOrder,
    <SUITE::POINT as Point>::SCALAR: ScalarCanCheckCanonical,
{
    /// PlaintextDeal returns the plaintext version of the deal destined for peer i.
    /// Use this only for testing.
    pub fn plaintext_deal(&mut self, i: usize) -> anyhow::Result<&mut Deal<SUITE>> {
        if i >= self.deals.len() {
            anyhow::bail!("dealer: PlaintextDeal given wrong index");
        }
        let d = &mut self.deals[i];
        Ok(d)
    }

    /// EncryptedDeal returns the encryption of the deal that must be given to the
    /// verifier at index i.
    /// The dealer first generates a temporary Diffie Hellman key, signs it using its
    /// longterm key, and computes the shared key depending on its longterm and
    /// ephemeral key and the verifier's public key.
    /// This shared key is then fed into a HKDF whose output is the key to a AEAD
    /// (AES256-GCM) scheme to encrypt the deal.
    pub fn encrypted_deal(&self, i: usize) -> anyhow::Result<EncryptedDeal<SUITE::POINT>> {
        let v_pub = find_pub(&self.verifiers, i)
            .ok_or_else(|| anyhow::Error::msg("dealer: wrong index to generate encrypted deal"))?;
        // gen ephemeral key
        let dh_secret = self.suite.scalar().pick(&mut self.suite.random_stream());
        let dh_public = self.suite.point().mul(&dh_secret, None);
        // signs the public key
        let dh_public_buff = dh_public.marshal_binary()?;
        let signature = schnorr::sign(&self.suite, &self.long, &dh_public_buff)?;

        // AES128-GCM
        let pre = SUITE::dh_exchange(self.suite, dh_secret, v_pub);
        let gcm = AEAD::<SUITE>::new(pre, &self.hkdf_context)?;
        let nonce = [0u8; NONCE_SIZE];
        // let dealBuff = protobuf.Encode(self.deals[i])?;
        let deal_buf = self.deals[i].marshal_binary()?;
        let encrypted = gcm.seal(None, &nonce, &deal_buf, Some(&self.hkdf_context))?;
        Ok(EncryptedDeal {
            dhkey: dh_public,
            signature,
            nonce: nonce.to_vec(),
            cipher: encrypted,
        })
    }

    /// encrypted_deals calls `EncryptedDeal` for each index of the verifier and
    /// returns the list of encrypted deals. Each index in the returned slice
    /// corresponds to the index in the list of verifiers.
    pub fn encrypted_deals(&self) -> anyhow::Result<Vec<EncryptedDeal<SUITE::POINT>>> {
        // deals := make([]*EncryptedDeal, len(d.verifiers));
        let mut deals = vec![];
        // var err error
        for i in 0..self.verifiers.len() {
            let deal = self.encrypted_deal(i)?;
            deals.push(deal);
        }
        Ok(deals)
    }

    /// process_response analyzes the given Response. If it's a valid complaint, then
    /// it returns a Justification. This Justification must be broadcasted to every
    /// participants. If it's an invalid complaint, it returns an error about the
    /// complaint. The verifiers will also ignore an invalid Complaint.
    pub fn process_response(
        &mut self,
        r: &Response,
    ) -> anyhow::Result<Option<Justification<SUITE>>> {
        self.aggregator.verify_response(r)?;

        if r.status == STATUS_APPROVAL {
            return Ok(None);
        }

        let mut j = Justification {
            session_id: self.session_id.clone(),
            // index is guaranteed to be good because of d.verifyResponse before
            index: r.index,
            deal: self.deals[r.index as usize].clone(),
            signature: vec![],
        };

        let msg = &j.clone().hash(self.suite)?;
        let sig = schnorr::sign(&self.suite, &self.long, msg)?;
        j.signature = sig;

        Ok(Some(j))
    }

    /// SecretCommit returns the commitment of the secret being shared by this
    /// dealer. This function is only to be called once the deal has enough approvals
    /// and is verified otherwise it returns nil.
    pub fn secret_commit(&self) -> Option<SUITE::POINT> {
        if !self.aggregator.deal_certified() {
            return None;
        }
        Some(self.suite.point().mul(&self.secret, None))
    }

    /// Commits returns the commitments of the coefficient of the secret polynomial
    /// the Dealer is sharing.
    pub fn commits(&self) -> Vec<SUITE::POINT> {
        self.secret_commits.clone()
    }

    /// Key returns the longterm key pair used by this Dealer.
    pub fn key(&self) -> (<SUITE::POINT as Point>::SCALAR, SUITE::POINT) {
        (self.long.clone(), self.pubb.clone())
    }

    /// SessionID returns the current sessionID generated by this dealer for this
    /// protocol run.
    pub fn session_id(&self) -> Vec<u8> {
        self.session_id.clone()
    }

    /// SetTimeout marks the end of a round, invalidating any missing (or future) response
    /// for this DKG protocol round. The caller is expected to call this after a long timeout
    /// so each DKG node can still compute its share if enough Deals are valid.
    pub fn set_timeout(&mut self) {
        self.aggregator.timeout = true
    }

    /// PrivatePoly returns the private polynomial used to generate the deal. This
    /// private polynomial can be saved and then later on used to generate new
    /// shares.  This information SHOULD STAY PRIVATE and thus MUST never be given
    /// to any third party.
    pub fn private_poly(&self) -> share::poly::PriPoly<SUITE> {
        self.secret_poly.clone()
    }
}

/// Verifier receives a Deal from a Dealer, can reply with a Complaint, and can
/// collaborate with other Verifiers to reconstruct a secret.
#[derive(Clone)]
pub struct Verifier<SUITE: Suite> {
    suite: SUITE,
    pub(crate) longterm: <SUITE::POINT as Point>::SCALAR,
    pub(crate) pubb: SUITE::POINT,
    dealer: SUITE::POINT,
    pub(crate) index: usize,
    verifiers: Vec<SUITE::POINT>,
    hkdf_context: Vec<u8>,
    pub(crate) aggregator: Option<Aggregator<SUITE>>,
}

/// NewVerifier returns a Verifier out of:
///   - its longterm secret key
///   - the longterm dealer public key
///   - the list of public key of verifiers. The list MUST include the public key of this Verifier also.
///
/// The security parameter t of the secret sharing scheme is automatically set to
/// a default safe value. If a different t value is required, it is possible to set
/// it with `verifier.SetT()`.
pub fn new_verifier<SUITE: Suite>(
    suite: &SUITE,
    longterm: &<SUITE::POINT as Point>::SCALAR,
    dealer_key: &SUITE::POINT,
    verifiers: &[SUITE::POINT],
) -> anyhow::Result<Verifier<SUITE>> {
    let pubb = suite.point().mul(longterm, None);
    let mut ok = false;
    let mut index = 0;
    for (i, v) in verifiers.iter().enumerate() {
        if v.equal(&pubb) {
            ok = true;
            index = i;
            break;
        }
    }
    if !ok {
        anyhow::bail!("vss: public key not found in the list of verifiers");
    }
    let c = context(suite, dealer_key, verifiers);
    Ok(Verifier {
        suite: *suite,
        longterm: longterm.clone(),
        dealer: dealer_key.clone(),
        verifiers: verifiers.to_vec(),
        pubb,
        index,
        hkdf_context: c,
        aggregator: Some(new_empty_aggregator(*suite, verifiers)),
    })
}

impl<SUITE: Suite> Deref for Verifier<SUITE> {
    type Target = Aggregator<SUITE>;

    fn deref(&self) -> &Self::Target {
        self.aggregator.as_ref().unwrap()
    }
}

impl<SUITE: Suite> DerefMut for Verifier<SUITE> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.aggregator.as_mut().unwrap()
    }
}

impl<SUITE: Suite> Verifier<SUITE>
where
    SUITE::POINT: PointCanCheckCanonicalAndSmallOrder,
    <SUITE::POINT as Point>::SCALAR: ScalarCanCheckCanonical,
{
    /// ProcessEncryptedDeal decrypt the deal received from the Dealer.
    /// If the deal is valid, i.e. the verifier can verify its shares
    /// against the public coefficients and the signature is valid, an approval
    /// response is returned and must be broadcasted to every participants
    /// including the dealer.
    /// If the deal itself is invalid, it returns a complaint response that must be
    /// broadcasted to every other participants including the dealer.
    /// If the deal has already been received, or the signature generation of the
    /// response failed, it returns an error without any responses.
    pub fn process_encrypted_deal(
        &mut self,
        e: &EncryptedDeal<SUITE::POINT>,
    ) -> anyhow::Result<Response> {
        let d = self.decrypt_deal(e)?;
        if d.sec_share.i != self.index {
            anyhow::bail!("vss: verifier got wrong index from deal");
        }

        let t = d.t;

        let sid = session_id(
            &self.suite,
            &self.dealer,
            &self.verifiers,
            &d.commitments,
            t,
        )?;

        let mut r = Response {
            session_id: sid,
            index: self.index as u32,
            status: STATUS_APPROVAL,
            ..Default::default()
        };
        let result = self.verify_deal(&d, true);

        if let Err(err) = result {
            r.status = STATUS_COMPLAINT;
            // TODO: manage error
            match err {
                VerifyDealError::DealAlreadyProcessedError => anyhow::bail!(err),
                VerifyDealError::TextError(e) => {
                    if !e.eq("vss: share does not verify against commitments in Deal") {
                        anyhow::bail!(e)
                    }
                }
            }
        }

        r.signature = schnorr::sign(
            &self.suite,
            &self.longterm.clone(),
            r.hash(&self.suite)?.as_slice(),
        )?;

        self.aggregator.as_mut().unwrap().add_response(&r)?;
        Ok(r)
    }

    pub fn decrypt_deal(&self, e: &EncryptedDeal<SUITE::POINT>) -> anyhow::Result<Deal<SUITE>> {
        let eph_buff = e.dhkey.marshal_binary()?;
        // verify signature
        schnorr::verify(
            self.suite,
            &self.dealer.clone(),
            eph_buff.as_slice(),
            &e.signature,
        )?;

        // compute shared key and AES526-GCM cipher
        let pre = SUITE::dh_exchange(self.suite, self.longterm.clone(), e.dhkey.clone());
        let gcm = AEAD::<SUITE>::new(pre, &self.hkdf_context)?;
        let decrypted = gcm.open(
            None,
            e.nonce.as_slice().try_into().unwrap(),
            &e.cipher,
            Some(self.hkdf_context.as_slice()),
        )?;
        Deal::decode(&decrypted)
    }

    /// ProcessResponse analyzes the given response. If it's a valid complaint, the
    /// verifier should expect to see a Justification from the Dealer. It returns an
    /// error if it's not a valid response.
    /// Call `v.DealCertified()` to check if the whole protocol is finished.
    pub fn process_response(&mut self, resp: &Response) -> anyhow::Result<()> {
        match &mut self.aggregator {
            Some(aggregator) => aggregator.verify_response(resp),
            None => anyhow::bail!("no aggregator for verifier"),
        }
    }

    /// Commits returns the commitments of the coefficients of the polynomial
    /// contained in the Deal received. It is public information. The private
    /// information in the deal must be retrieved through Deal().
    pub fn commits(&self) -> Option<Vec<SUITE::POINT>> {
        self.deal.as_ref().map(|d| d.commitments.clone())
    }

    /// Deal returns the Deal that this verifier has received. It returns
    /// nil if the deal is not certified or there is not enough approvals.
    pub fn deal(&self) -> Option<Deal<SUITE>> {
        if !self.deal_certified() {
            return None;
        }
        self.deal.clone()
    }

    /// ProcessJustification takes a DealerResponse and returns an error if
    /// something went wrong during the verification. If it is the case, that
    /// probably means the Dealer is acting maliciously. In order to be sure, call
    /// `v.DealCertified()`.
    pub fn process_justification(&mut self, dr: &Justification<SUITE>) -> anyhow::Result<()> {
        match &mut self.aggregator {
            Some(a) => a.verify_justification(dr),
            None => anyhow::bail!("missing aggregator"),
        }
    }

    /// Key returns the longterm key pair this verifier is using during this protocol
    /// run.
    pub fn key(self) -> (<SUITE::POINT as Point>::SCALAR, SUITE::POINT) {
        (self.longterm, self.pubb)
    }

    /// Index returns the index of the verifier in the list of participants used
    /// during this run of the protocol.
    pub fn index(&self) -> usize {
        self.index
    }

    /// SessionID returns the session id generated by the Dealer. WARNING: it returns
    /// an nil slice if the verifier has not received the Deal yet !
    pub fn session_id(&self) -> Vec<u8> {
        self.sid.clone()
    }

    /// SetTimeout marks the end of the protocol. The caller is expected to call this
    /// after a long timeout so each verifier can still deem its share valid if
    /// enough deals were approved. One should call `DealCertified()` after this
    /// method in order to know if the deal is valid or the protocol should abort.
    pub fn set_timeout(&mut self) {
        if let Some(a) = self.aggregator.as_mut() {
            a.timeout = true;
        }
    }

    /// UnsafeSetResponseDKG is an UNSAFE bypass method to allow DKG to use VSS
    /// that works on basis of approval only.
    #[allow(unused_must_use)]
    pub fn unsafe_set_response_dkg(&mut self, idx: u32, approval: bool) {
        let r = Response {
            session_id: self.sid.clone(),
            index: idx,
            status: approval,
            signature: vec![],
        };

        self.add_response(&r);
    }
}

/// RecoverSecret recovers the secret shared by a Dealer by gathering at least t
/// Deals from the verifiers. It returns an error if there is not enough Deals or
/// if all Deals don't have the same SessionID.
pub fn recover_secret<SUITE: Suite>(
    suite: SUITE,
    deals: Vec<Deal<SUITE>>,
    n: usize,
    t: usize,
) -> anyhow::Result<<SUITE::POINT as Point>::SCALAR> {
    let mut shares = Vec::with_capacity(deals.len());
    for deal in &deals {
        // all sids the same
        if deal.session_id == deals[0].session_id {
            shares.push(Some(deal.sec_share.clone()));
        } else {
            anyhow::bail!("vss: all deals need to have same session id");
        }
    }
    // TODO fix this error management
    share::poly::recover_secret(suite, &shares, t, n).map_err(|e| anyhow::Error::msg(""))
}

#[derive(Debug, Clone)]
pub enum VerifyDealError {
    DealAlreadyProcessedError,
    TextError(String),
}

impl fmt::Display for VerifyDealError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerifyDealError::DealAlreadyProcessedError => self.fmt(f),
            VerifyDealError::TextError(t) => write!(f, "{}", t),
        }
    }
}

impl std::error::Error for VerifyDealError {}

#[derive(Debug, Clone)]
struct DealAlreadyProcessedError;

impl fmt::Display for DealAlreadyProcessedError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "vss: verifier already received a deal")
    }
}

/// ErrNoDealBeforeResponse is an error returned if a verifier receives a
/// deal before having received any responses. For the moment, the caller must
/// be sure to have dispatched a deal before.
#[derive(Debug, Clone)]
struct ErrNoDealBeforeResponse;

impl fmt::Display for ErrNoDealBeforeResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "verifier: need to receive deal before response")
    }
}

/// Aggregator is used to collect all deals, and responses for one protocol run.
/// It brings common functionalities for both Dealer and Verifier structs.
#[derive(Clone)]
pub struct Aggregator<SUITE: Suite> {
    pub suite: SUITE,
    dealer: SUITE::POINT,
    pub verifiers: Vec<SUITE::POINT>,
    commits: Vec<SUITE::POINT>,

    pub(crate) responses: HashMap<u32, Response>,
    pub(crate) sid: Vec<u8>,
    pub(crate) deal: Option<Deal<SUITE>>,
    pub(crate) t: usize,
    pub(crate) bad_dealer: bool,
    pub(crate) timeout: bool,
}

fn new_aggregator<SUITE: Suite>(
    suite: &SUITE,
    dealer: &SUITE::POINT,
    verifiers: &[SUITE::POINT],
    commitments: &[SUITE::POINT],
    t: usize,
    sid: &[u8],
) -> Aggregator<SUITE> {
    Aggregator {
        suite: *suite,
        dealer: dealer.clone(),
        verifiers: verifiers.to_vec(),
        commits: commitments.to_vec(),
        t,
        sid: sid.to_vec(),
        responses: HashMap::new(),
        deal: None,
        bad_dealer: false,
        timeout: false,
    }
}

impl<SUITE: Suite> Default for Aggregator<SUITE> {
    fn default() -> Self {
        Self {
            suite: Default::default(),
            dealer: Default::default(),
            verifiers: Default::default(),
            commits: Default::default(),
            responses: Default::default(),
            sid: Default::default(),
            deal: Default::default(),
            t: Default::default(),
            bad_dealer: Default::default(),
            timeout: Default::default(),
        }
    }
}

/// NewEmptyAggregator returns a structure capable of storing Responses about a
/// deal and check if the deal is certified or not.
pub fn new_empty_aggregator<SUITE: Suite>(
    suite: SUITE,
    verifiers: &[SUITE::POINT],
) -> Aggregator<SUITE> {
    Aggregator {
        suite,
        verifiers: verifiers.to_vec(),
        responses: HashMap::new(),
        ..Default::default()
    }
}

impl<SUITE: Suite> Aggregator<SUITE>
where
    <SUITE::POINT as Point>::SCALAR: ScalarCanCheckCanonical,
    SUITE::POINT: PointCanCheckCanonicalAndSmallOrder,
{
    /// VerifyDeal analyzes the deal and returns an error if it's incorrect. If
    /// inclusion is true, it also returns an error if it is the second time this struct
    /// analyzes a Deal.
    pub fn verify_deal(&mut self, d: &Deal<SUITE>, inclusion: bool) -> Result<(), VerifyDealError> {
        if self.deal.is_some() && inclusion {
            return Err(VerifyDealError::DealAlreadyProcessedError);
        }
        if self.deal.is_none() {
            self.commits = d.commitments.clone();
            self.sid = d.session_id.clone();
            self.deal = Some(d.clone());
            self.t = d.t;
        }

        if !valid_t(d.t, &self.verifiers) {
            return Err(VerifyDealError::TextError(
                "vss: invalid t received in Deal".to_string(),
            ));
        }

        if d.t != self.t {
            return Err(VerifyDealError::TextError(
                "vss: incompatible threshold - potential attack".to_string(),
            ));
        }

        if self.sid != d.session_id {
            return Err(VerifyDealError::TextError(
                "vss: find different sessionIDs from Deal".to_string(),
            ));
        }

        let fi = &d.sec_share;
        if fi.i >= self.verifiers.len() {
            return Err(VerifyDealError::TextError(
                "vss: index out of bounds in Deal".to_string(),
            ));
        }
        // compute fi * G
        let fig = self.suite.point().base().mul(&fi.v, None);

        let commit_poly = share::poly::PubPoly::new(&self.suite, None, &d.commitments);

        let pub_share = commit_poly.eval(fi.i);
        if !fig.equal(&pub_share.v) {
            return Err(VerifyDealError::TextError(
                "vss: share does not verify against commitments in Deal".to_string(),
            ));
        }
        Ok(())
    }

    /// SetThreshold is used to specify the expected threshold *before* the verifier
    /// receives anything. Sometimes, a verifier knows the treshold in advance and
    /// should make sure the one it receives from the dealer is consistent. If this
    /// method is not called, the first threshold received is considered as the
    /// "truth".
    pub fn set_threshold(&mut self, t: usize) {
        self.t = t
    }

    /// ProcessResponse verifies the validity of the given response and stores it
    /// internall. It is  the public version of verifyResponse created this way to
    /// allow higher-level package to use these functionalities.
    pub fn process_response(&mut self, r: Response) -> anyhow::Result<()> {
        self.verify_response(&r)
    }

    pub fn verify_response(&mut self, r: &Response) -> anyhow::Result<()> {
        if !self.sid.is_empty() && r.session_id != self.sid {
            anyhow::bail!(
                "vss: receiving inconsistent sessionID in response: {:?} vs {:?}",
                r.session_id,
                self.sid
            )
        }

        let public = find_pub(&self.verifiers, r.index as usize);
        if public.is_none() {
            anyhow::bail!("vss: index out of bounds in response")
        }

        let msg = r.hash(&self.suite)?;

        schnorr::verify(self.suite, &public.unwrap(), &msg, &r.signature)?;

        self.add_response(r)
    }

    fn verify_justification(&mut self, j: &Justification<SUITE>) -> anyhow::Result<()> {
        let pubb = find_pub(&self.verifiers, j.index as usize);
        if pubb.is_none() {
            anyhow::bail!("vss: index out of bounds in justification")
        }

        if !self.responses.contains_key(&j.index) {
            anyhow::bail!("vss: no complaints received for this justification")
        }

        // clone the resp here
        let mut r = self.responses[&j.index].clone();

        if r.status != STATUS_COMPLAINT {
            anyhow::bail!("vss: justification received for an approval")
        }

        match self.verify_deal(&j.deal, false) {
            Ok(_) => r.status = STATUS_APPROVAL,
            Err(err) => {
                // if one justification is bad, then flag the dealer as malicious
                self.bad_dealer = true;
                return Err(anyhow::format_err!(err));
            }
        }
        Ok(())
    }

    pub fn add_response(&mut self, r: &Response) -> anyhow::Result<()> {
        if find_pub(&self.verifiers, r.index as usize).is_none() {
            anyhow::bail!("vss: index out of bounds in Complaint");
        }
        if self.responses.get(&r.index).is_some() {
            anyhow::bail!("vss: already existing response from same origin")
        }
        self.responses.insert(r.index, r.clone());
        Ok(())
    }

    /// Responses returns the list of responses received and processed by this
    /// aggregator
    pub fn responses(&self) -> &HashMap<u32, Response> {
        &self.responses
    }

    /// DealCertified returns true if the deal is certified.
    /// For a deal to be certified, it needs to comply to the following
    /// conditions in two different cases, since we are not working with the
    /// synchrony assumptions from Feldman's VSS:
    /// Before the timeout (i.e. before the "period" ends):
    /// 1. there is at least t approvals
    /// 2. all complaints must be justified (a complaint becomes an approval when
    /// justified) -> no complaints
    /// 3. there must not be absent responses
    /// After the timeout, when the "period" ended, we replace the third condition:
    /// 3. there must not be more than n-t missing responses (otherwise it is not
    /// possible to retrieve the secret).
    /// If the caller previously called `SetTimeout` and `DealCertified()` returns
    /// false, the protocol MUST abort as the deal is not and never will be validated.
    pub fn deal_certified(&self) -> bool {
        let mut absent_verifiers = 0usize;
        let mut approvals = 0usize;
        let mut is_complaint = false;

        for (i, _) in self.verifiers.iter().enumerate() {
            if !self.responses.contains_key(&(i as u32)) {
                absent_verifiers += 1;
            } else {
                match self.responses.get(&(i as u32)).unwrap().status {
                    STATUS_COMPLAINT => is_complaint = true,
                    STATUS_APPROVAL => approvals += 1,
                }
            }
        }
        let enough_approvals = approvals >= self.t;
        let too_much_absents = absent_verifiers > self.verifiers.len() - self.t;
        let base_condition = !self.bad_dealer && enough_approvals && !is_complaint;
        if self.timeout {
            return base_condition && !too_much_absents;
        }
        base_condition && absent_verifiers == 0
    }

    /// MissingResponses returns the indexes of the expected but missing responses.
    pub fn missing_responses(&self) -> Vec<usize> {
        let mut absents = Vec::new();
        for (i, _) in self.verifiers.iter().enumerate() {
            if !self.responses.contains_key(&(i as u32)) {
                absents.push(i);
            }
        }
        absents
    }
}

/// minimum_t returns the minimum safe T that is proven to be secure with this
/// protocol. It expects n, the total number of participants.
/// WARNING: Setting a lower T could make
/// the whole protocol insecure. Setting a higher T only makes it harder to
/// reconstruct the secret.
pub fn minimum_t(n: usize) -> usize {
    (n + 1) / 2
}

fn valid_t<POINT: Point>(t: usize, verifiers: &[POINT]) -> bool {
    t >= 2 && t <= verifiers.len() && (t as u32) as i64 == t as i64
}

pub fn derive_h<SUITE: Suite>(suite: SUITE, verifiers: &[SUITE::POINT]) -> SUITE::POINT {
    let mut b = vec![];
    for v in verifiers {
        v.marshal_to(&mut b).unwrap();
    }
    let base = suite.point().pick(&mut suite.xof(Some(&b)));
    base
}

pub(crate) fn find_pub<POINT: Point>(verifiers: &[POINT], idx: usize) -> Option<POINT> {
    verifiers.get(idx).cloned()
}

pub(crate) fn session_id<SUITE: Suite>(
    suite: &SUITE,
    dealer: &SUITE::POINT,
    verifiers: &[SUITE::POINT],
    commitments: &[SUITE::POINT],
    t: usize,
) -> anyhow::Result<Vec<u8>> {
    let mut h = suite.hash();
    dealer.marshal_to(&mut h)?;

    for v in verifiers {
        v.marshal_to(&mut h)?;
    }

    for c in commitments {
        c.marshal_to(&mut h)?;
    }

    h.write_u32::<LittleEndian>(t as u32)?;

    Ok(h.finalize().to_vec())
}

/// context returns the context slice to be used when encrypting a share
pub fn context<SUITE: Suite>(
    suite: &SUITE,
    dealer: &SUITE::POINT,
    verifiers: &[SUITE::POINT],
) -> Vec<u8> {
    let mut h = suite.hash();
    h.write_all("vss-dealer".as_bytes()).unwrap();
    dealer.marshal_to(&mut h).unwrap();
    h.write_all("vss-verifiers".as_bytes()).unwrap();
    for v in verifiers {
        v.marshal_to(&mut h).unwrap();
    }
    h.finalize().to_vec()
}
